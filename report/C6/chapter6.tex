\chapter{Critical Evaluation}

In this chapter, I describe the set of experiments used to show the increase in performance from the implementation of the constraint-based approach. \\ \\
I have measured the performance by running both versions of the learner on five target problems, and returning both the generated code and the time taken to learn, as returned by clingo. The problems are defined by a set of Input / Output examples which cover enough cases to correctly learn the target function. Solutions are defined as a subset of the generated Answer Set, containing only \lstinline{choose}, \lstinline{choose_match} and \lstinline{choose_where} atoms, representing chosen rules from the skeleton rules. \\ \\%{ 
All examples have been run on --LAB PC SPECS-- \\ \\
The results from these experiments tend to show the result that apart from in the simple case, the constraint based approach performs around 50\% better than the interpreted approach across all examples. In the simple factorial example, the interpreted approach was quicker due to the small set of skeleton rules effecting performance in relatively small way. \\ \\
However, the constraint based approach is less expressive, as highlighted by the fibonacci example. The fibonacci program consists of two recursive calls, which cannot be learned by this approach as it becomes difficult to maintain the equality constraints. For example, consider the equality constraint
\begin{lstlisting}
eq(add(call(f, (x - 1)), call(f, (x - 2))), 4).
\end{lstlisting}
The tool cannot continue evaluating this constraint as it does not know the value of either \lstinline{call} expressions.

\pagebreak
\section{One Argument Programs}

\subsection{Factorial}
\underline{\textbf{Input Examples}}
\begin{lstlisting}
example(call(fac, 0), 1).
example(call(fac, 1), 1).
example(call(fac, 2), 2).
example(call(fac, 3), 6).
\end{lstlisting}

\begin{multicols*}{2}

\underline{\textbf{Interpreted approach results}}
\begin{lstlisting}
choose_match(1,1,0) 
choose_match(2,2) 
choose(1,3,1) 
choose(2,9) 
choose_where(34) 
choose_where(45,1) 

Models      : 1     
Optimization: 2 3 
Time        : 1.640
  Prepare   : 0.060
  Prepro.   : 0.020
  Solving   : 1.560


\end{lstlisting}

\begin{lstlisting}
fac x
  | x == 0 = 1
  | otherwise = x * x0
  where x0 = f x1
  	where x1 = x - 1
\end{lstlisting}
\vfill
\columnbreak
\underline{\textbf{Constraint approach results}}

\begin{lstlisting}
choose_match(1,1,0)
choose_match(2,2) 
choose(1,1,1) 
choose(2,37,1) 



Models      : 1     
Optimization: 1 
Time        : 1.240
  Prepare   : 0.200
  Prepro.   : 0.140
  Solving   : 0.900
\end{lstlisting}

\begin{lstlisting}
fac x
  | x == 0 = 1
  | otherwise = (fac (x - 1)) * x
\end{lstlisting}
\end{multicols*}

\subsection{Fibonacci}
\underline{\textbf{Input Examples}}
\begin{lstlisting}
example(call(f, 1), 1).
example(call(f, 2), 1).
example(call(f, 3), 2).
example(call(f, 4), 3).
example(call(f, 5), 5).
example(call(f, 6), 8).
\end{lstlisting}

\begin{multicols*}{2}
\underline{\textbf{Interpreted approach results}}
\begin{lstlisting}
choose_match(1,1,1) 
choose_match(2,1,2) 
choose_match(3,2) 
choose(1,1) 
choose(2,13,1) 
choose(3,84) 
choose_where(30,1) 
choose_where(49) 
choose_where(83) 
choose_where(75,2) 

Models      : 1     
Optimization: 4 1 
Time        : 807.240
  Prepare   : 0.060
  Prepro.   : 0.020
  Solving   : 807.160

fib x
  | x == 1 = x
  | x == 2 = x - 1
  | otherwise = x0 + x2
  where x0 = fib x1
  	where x1 = x - 1
  		where x2 = fib x3
  			where x3 = x - 2
\end{lstlisting}
\vfill
\columnbreak
\underline{\textbf{Constraint approach results}}
\begin{lstlisting}
UNSATISFIABLE

Models      : 0     
Time        : 0.020
  Prepare   : 0.020
  Prepro.   : 0.000
  Solving   : 0.000
\end{lstlisting}
\end{multicols*}

\pagebreak
\subsection{Powers of 2}
\underline{\textbf{Input Examples}}
\begin{lstlisting}
example(call(f, 0), 1).
example(call(f, 1), 2).
example(call(f, 2), 4).
example(call(f, 3), 8).
\end{lstlisting}

\begin{multicols*}{2}
\underline{\textbf{Interpreted approach results}}
\begin{lstlisting}
choose_match(1,1,0) 
choose_match(2,2) 
choose(1,3,1) 
choose(2,84) 
choose_where(30,1) 
choose_where(49) 
choose_where(64) 

Models      : 1     
Optimization: 3 3 
Time        : 35.840
  Prepare   : 0.040
  Prepro.   : 0.040
  Solving   : 35.760

power2 x
  | x == 0 = x + 1
  | otherwise = x1 + x2
  	where x1 = f x0
  		where x2 = f x0
  			where x0 = x - 1
\end{lstlisting}
\vfill
\columnbreak
\underline{\textbf{Constraint approach results}}
\begin{lstlisting}
choose_match(1,1,0) 
choose_match(2,2)
choose(1,1,1)
choose(2,38,1,2) 
 
 
 
 
Models      : 1  
Optimization: 1 
Time        : 5.580
  Prepare   : 0.380
  Prepro.   : 0.340
  Solving   : 4.860

power2 x
  | x == 1 = 1
  | otherwise = (f (x - 1)) * 2 
\end{lstlisting}
\end{multicols*}
\pagebreak
\section{Two Argument Programs}

\subsection{Tail Recursive Factorial}
\underline{\textbf{Input Examples}}
\begin{lstlisting}
example(call(f, (0, 1)), 1).
example(call(f, (1, 1)), 1).
example(call(f, (2, 1)), 2).
example(call(f, (3, 1)), 6).
example(call(f, (2, 3)), 6).
\end{lstlisting}

\begin{multicols*}{2}
\underline{\textbf{Interpreted approach results}}
\begin{lstlisting}
choose_match(1,1,0)
choose_match(2,7)
choose(1,2) 
choose(2,27) 
choose_where(51,1)
choose_where(69) 

Models      : 1     
Optimization: 2 2 
Time        : 419.860
  Prepare   : 2.060
  Prepro.   : 0.840
  Solving   : 416.960
\end{lstlisting}

\begin{lstlisting}
fac x y
  | x == 0 = y
  | otherwise = fac x0 x1
  where x0 = x - 1
  	where x1 = x * y
\end{lstlisting}
\vfill
\columnbreak
\underline{\textbf{Constraint approach results}}
\begin{lstlisting}
choose_match(1,2,0)
choose_match(2,1) 
choose(1,3) 
choose(2,184,1) 

 
 
Models      : 1     
Optimization: 3 
Time        : 173.900
  Prepare   : 5.540
  Prepro.   : 1.440
  Solving   : 166.920

\end{lstlisting}
\begin{lstlisting}
fac x y
  | x == 0 = y
  | otherwise = fac (x - 1) (x * y)
\end{lstlisting}
\end{multicols*}
\pagebreak
\subsection{Greatest Common Divisor}
\underline{\textbf{Input Examples}}
\begin{lstlisting}
example(call(gcd, (1, 1)), 1).
example(call(gcd, (2, 1)), 1).
example(call(gcd, (4, 3)), 1).
example(call(gcd, (3, 6)), 3).
example(call(gcd, (9, 6)), 3).
example(call(gcd, (4, 7)), 1).
example(call(gcd, (9, 3)), 3).
\end{lstlisting}
\begin{multicols*}{2}
\underline{\textbf{Interpreted approach results}}
\begin{lstlisting}
choose_match(1,2,0) 
choose_match(2,6) 
choose_match(3,7)   
choose(1,1) 
choose(2,30) 
choose(3,81) 
choose_where(53) 
choose_where(77) 

Models      : 1     
Optimization: 1 2 
Time        : 1546.820
  Prepare   : 1.940
  Prepro.   : 0.980
  Solving   : 1543.900
  
gcd x y
  | y == 0 = x
  | x > y = gcd y x0
  | otherwise = gcd x1 x
  where x0 = x - y
  	where x1 = y - x
\end{lstlisting}
\vfill
\columnbreak
\underline{\textbf{Constraint approach results}}
\begin{lstlisting}
choose_match(1,3)
choose_match(2,4)
choose_match(3,6)  
choose(1,2) 
choose(2,150) 
choose(3,190) 



Models      : 1     
Optimization: 2 
Time        : 1599.420
  Prepare   : 11.720
  Prepro.   : 2.100
  Solving   : 1585.600

gcd x y
	| x == y = x
	| x > y	 = gcd (x - y) y
	| x < y	 = gcd y x
\end{lstlisting}
\end{multicols*}
\pagebreak
\section{Comparison to Existing Tools}

In this section, I will detail how other existing inductive functional programming (IFP) tools perform in comparison to mine, highlighting any benefits or restrictions to both mine and the existing tools. More information on these tools can be found in the background section. \\ \\
For evaluation, I have ran both systems on the examples detailed in the section above, showing a comparison between code generated and running time between both existing systems and my tool's constraint based approach.

\subsection{MagicHaskeller}
MagicHaskeller is an IFP system that is based on the generate-and-test approach to IFP. It works by systematically generating a stream of gradually more complicated functions (based on length), and keeping the ones which cover the input examples. The system is made more efficient through smart restrictions of target programs based on the type of the input examples, and through heavy use of in built functions, both linear and higher order. \\ \\
Input to MagicHaskeller is any Haskell expression which returns a boolean value, as long as it does not contain any \lstinline{let} or \lstinline{while} clauses. For example, to learn the factorial program, you can give as input the examples \lstinline{\f -> ( f 0 == 1 )  && ( f 1 == 1 )  && ( f 2 == 2 )  && ( f 3 == 6 )}. Here, each positive example is concatenated with \lstinline{&&} to produce the overall input.\\ \\
Full tables of generated programs and performance timings can be found respectively in tables \ref{table:1} and \ref{table:2} \\ \\
What is notable from these results is that MagicHaskeller fails to learn direct recursion, relying instead on its large library of in-built functions. This is most visible on the GCD and Fibonacci examples, where MagicHaskeller can simply make use of Haskell's inbuilt gcd function, but cannot learn the purely recursive Fibonacci. This is because of a deliberate choice by the creator of MagicHaskeller, as removing direct recursion decreases the complexity of the search space.

\begin{table}[h!]
\centering
\begin{tabular}{| m{4em} | c | c |}
\hline
\multicolumn{3}{|c|}{\textbf{Generated Code}} \\
\hline
Function & My Solution & MagicHaskeller Solution \\
\hline
Factorial 
&
\begin{lstlisting}
f x
  | x == 0 = 1
  | otherwise = x * f(x - 1)
\end{lstlisting}
& 
\begin{lstlisting}
f = 
  (\a -> product [1..a])
\end{lstlisting}
\\
\hline
\mbox{}\newline
Tail \newline
Recursive \newline
Factorial \newline
&
\begin{lstlisting}
f x n
  | x == 0 = n
  | otherwise = f (x - 1) (x * n)
\end{lstlisting}
& 
\begin{lstlisting}
f = 
  (\a b -> product [b..a])
\end{lstlisting}
\\
\hline
GCD 
&
\begin{lstlisting}
gcd x y
  | x == y = x
  | x > y  = gcd x - y y
  | x < y  = gcd y x
\end{lstlisting}	
&
\begin{lstlisting}
f = (flip gcd)
\end{lstlisting}
\\
\hline
Fibonacci
&
\begin{lstlisting}
fib x
  | x == 1 = x
  | x == 2 = x - 1
  | otherwise = x0 + x2
  where x0 = fib x1
  	where x1 = x - 1
  		where x2 = fib x3
  			where x3 = x - 2
\end{lstlisting}
&
No Result!
\\
\hline
\end{tabular}
\caption{MagicHaskeller Generated Code Comparison }
\label{table:1}
\end{table}

\begin{table}[h!]
\centering
\begin{tabular}{|c|c|c|}
\hline
\multicolumn{3}{|c|}{\textbf{Performance}}\\
\hline
Function & My Performance & MagicHaskeller \\
\hline
Factorial & & \\
\hline
Tail Recursive Factorial & & \\
\hline
GCD & & \\
\hline
Fibonacci & & \\
\hline
\end{tabular}
\caption{MagicHaskeller Performance Comparison }
\label{table:2}
\end{table}
\mbox{} \\

\subsection{Igor II}


\pagebreak
%\renewcommand\bibname{{References}}
%\bibliography{References}
%\bibliographystyle{plain}