\chapter{The Initial Approach : A Haskell Interpreter in ASP}

In this chapter, I describe the Haskell Interpreter that is used heavily in my first learning attempt. Given a set of ASP rules representing some Haskell function and a valid input to this function, this interpreter returns the output from running that function with those examples.

\section{Target Language}

Initially, I chose to target a simple subset of the Haskell syntax, emulating the following language features :

\begin{itemize}
\item Addition
\item Subtraction
\item Multiplication
\item Function calls with arbitrary number of arguments.
\item Recursion
\item Guards
%\item Lists
\end{itemize}
\mbox{}\\
To avoid overcomplication, I decided to not include lists in this first attempt, instead focusing on implementing recursion efficiently, making this is a sufficient feature set. 

\subsection{Program Representation}
To represent a generic Haskell program in ASP, first I had to choose various predicates to represent different parts of the program. By representing Haskell operations with logic predicates it becomes possible to evaluate operations on arbitrary expressions. Binary arithmetic operations are represented by corresponding binary predicates, and function calls by a binary predicate with arguments for function name and function arguments.  \\ \\

\begin{center}
\begin{tabular}{| c | c |}
\hline
\textbf{ASP Term} & \textbf{Haskell Syntax} \\
\hline
\lstinline!add(X, Y).! & \lstinline!x + y! \\
\hline
\lstinline!sub(X, Y).! & \lstinline!x - y! \\
\hline
\lstinline!mul(X, Y).! & \lstinline!x * y! \\
\hline
\lstinline!call(f, N).! & \lstinline!f n! \\
\hline
\end{tabular}
\end{center}
\mbox{}\\
Using these predicates, the representation the Haskell implementation of the recursive factorial program \\
\begin{lstlisting}
factorial x :: Int -> Int
factorial x 
	| x == 0 = 1
	| otherwise = x * f (x - 1)
\end{lstlisting}
\mbox{}\\
is given by the ASP terms \\
\begin{lstlisting}
rule(1, factorial, N, 1).
rule(2, factorial, N, mul(N, call(factorial, sub(N, 1)))).

match_guard(factorial, 1, Input) :- Input == 0.
match_guard(factorial, 2, Input).
\end{lstlisting}
\mbox{}\\
Each line (or recursive case) of the target Haskell program is represented by with a rule with a \lstinline!rule! term in the head, where the guard condition of each rule is represented by the corresponding \lstinline!match_guard! term.

\section{Evaluating Rules}

\subsubsection{Internal Predicates}
As part of the interpreter, I have declared a number of predicates used to represent various states of expression value throughout execution. 
 
\begin{center}
\begin{tabular}{| c | m{0.6\linewidth} |}
\hline
\textbf{ASP Term} & \textbf{Semantics} \\
\hline
\lstinline!rule(Index, F, Args, Expr).! 
&
\mbox{}\newline
A recursive case in the executed function. \newline
\lstinline!Index! represents which line number of the function where the case appears, used for identification.\newline
\lstinline!F! is the name of the function the case belongs to. \newline
\lstinline!Args! are the arguments of the function.\newline
\lstinline!Expr! is the expression that is evaluated when this recursive case is reached.\newline
\\
\hline
\lstinline!match_guard(F, Index, Inputs)! 
&
\mbox{}\newline
A guard statements, which shows what function inputs match a rule. The conditional is defined as the body of the rule, with the \lstinline!otherwise! case being represented by having no conditional. \newline
\lstinline!F! is the name of the function that matches. \newline
\lstinline!Index! represents which recursive case in the named function this term matches with. \newline
\lstinline!Inputs! represents what inputs match the respective case.\newline
\\
\hline
\lstinline!match(F, Index, Inputs)! 
&
\mbox{}\newline
Represents which function inputs match a respective line in the function. This is distinct from the \lstinline!match_guard! predicate as this predicate considers all possible matches and returns the correct one. \newline
\lstinline!F! is the name of the function that matches. \newline
\lstinline!Index! represents which recursive case in the named function this term matches with. \newline
\lstinline!Inputs! represents what inputs match the respective case.\newline
\\
\hline
\lstinline!input(call(F, Args))!
&
\mbox{}\newline
The input to the interpreter. \lstinline!call(F, Args)! is an expression representing a call to the function to be ran, with some arguments. \newline
\\
\hline
\lstinline!output(call(F, Args), Val)! 
& 
\mbox{}\newline
The output of the interpreter. \lstinline!call(F, Args)! is the input function call, and \lstinline!Val! is the value returned after that function has been executed. \newline
\\
\hline
\lstinline!eval(Expr)! 
& 
\mbox{}\newline
An expression to be evaluated. To avoid evaluating every possible expression, these terms are generated by the interpreter each time the value of an expression is needed. \newline
\lstinline!Expr! represents the arbitrary expression to be evaluated. \newline 
\\
\hline
\lstinline!value(Expr, Val)! 
& 
\mbox{}\newline
The value of an expression. After an expression is selected to be evaluated, its value is represented with this predicate.\newline 
\\
\hline
\end{tabular}
\end{center}
 
\subsubsection{Computation Rules}
To generate the above predicates, I needed to specify the relations between them. These generation (or computation) rules are detailed below. A full listing is available in Section 3.4 and in the Appendix.\\ \\
To start, a rule is needed to calculate the output, given inputs and a rule to follow. \\

\begin{lstlisting}[caption={Output generation}, label={lst:simple_out}, firstnumber=55]
output(call(F, Args), Out) :- 
		match(F, Index, Args), 
		rule(Index, F, Args, Expr), 
		value(Expr, Out).	
\end{lstlisting}
\mbox{} \\
\ref{lst:simple_out} generates output predicates if there is a rule that best matches the given arguments, and the output of that rule has a known value. \\

\begin{lstlisting}[caption={Match rules}, label={lst:simple_match}, firstnumber=123]
match(F, Index, Inputs) :- 
		not smaller_match(F, Index, Inputs), 
		rule(Index, F, Inputs, _), 
		match_guard(F, Index, Inputs).
	
smaller_match(F, Index, Args) :- match(F, O, Args), O < Index, const(Index).
\end{lstlisting}
\mbox{} \\
\ref{lst:simple_match} handles choosing which rule to use. A rule matches some inputs if there exists a rule with those inputs which does not match a a rule before it. \\

\begin{lstlisting}[caption={Eval introduction}, label={lst:simple_eval_init}, firstnumber=75]
eval(Expr) :- 
	input(call(F, Input)), 
	rule(Index, F, Input, Expr), 
	match(F, Index, Input).	
\end{lstlisting}
\mbox{}\\
\ref{lst:simple_eval_init} introduces \lstinline!eval! terms. If there is a call to a function as input, then evaluate the rule body which matches the arguments to the call. \\

\begin{lstlisting}[caption={Eval propagation}, label={lst:simple_eval}, firstnumber=77]
eval(Expr) :- eval(call(F, Expr)).
eval(A) :- eval(mul(A, B)).
eval(B) :- eval(mul(A, B)).
eval(A) :- eval(sub(A, B)).
eval(B) :- eval(sub(A, B)).
eval(A) :- eval(add(A, B)).
eval(B) :- eval(add(A, B)).
\end{lstlisting}
\mbox{}\\
In \ref{lst:simple_eval}, more \lstinline!eval! terms are generated. If a function call is to be evaluated, then its arguments should also be evaluated, and if an arithmetic expression is to be evaluated then both of its sub-expressions should be evaluated. \\ 

\begin{lstlisting}[caption={Value generation for arithmetic}, label={lst:simple_value_math}, firstnumber=69]
value(mul(A, B), V1 * V2) :- eval(mul(A, B)), value(A, V1), value(B, V2).
value(sub(A, B), V1 - V2) :- eval(sub(A, B)), value(A, V1), value(B, V2).
value(add(A, B), V1 + V2) :- eval(add(A, B)), value(A, V1), value(B, V2).
\end{lstlisting}
\mbox{}\\
\ref{lst:simple_value_math} details generating the values of arithmetic expressions. If both sub expressions have values \lstinline!V1! and \lstinline!V2! respectively, then the value of the overall expression is these values applied to the arithmetic expression. \\

\begin{lstlisting}[caption={Value generation for function calls}, label={lst:simple_value_fn}, firstnumber=72]
value(call(F, Expr), Out) :- 
		eval(call(F, Expr)), 
		output(call(F, Input), Out), 
		value(Expr, Input).	
value(N, N) :- eval(N).
\end{lstlisting}
\mbox{}\\
\ref{lst:simple_value_fn} describes value generation for function calls. If a function call has some output, then the value of that function call is that output. This rule works together with \ref{lst:simple_input}, which generates new \lstinline!input! terms, which then in turn generate new \lstinline!output! terms\\

\begin{lstlisting}[caption={Input generation}, label={lst:simple_input}, firstnumber=121]
input(call(F, Inputs)) :- eval(call(F, Args_new)), value(Args_new, Inputs).
\end{lstlisting}
\mbox{} \\
\ref{lst:simple_input} represents generation of more input predicates. If you have to evaluate a function call, and the arguments have value \lstinline!Inputs!, then you take the function call argument \lstinline!Inputs! as additional function input. This rule semantically represents calling the interpreter with a new input.

\subsection{Solutions}
The output from the interpreter is a subset of the Answer Set generated when ran with the ASP solver, \textit{clingo}. Although this Answer Set contains all the ground atoms generated throughout execution, the subset which represents the interpreter output contains only \lstinline!output! atoms. One \lstinline!output! atom is generated each time a function is called, for example when the factorial program is ran with initial input \lstinline!input(call(factorial, 3))!, the solution contains the atoms \\

\begin{lstlisting}
output(call(f, 0), 1)
output(call(f, 1), 1) 
output(call(f, 2), 2) 
output(call(f, 3), 6)
\end{lstlisting}
\mbox{}\\
The overall solution is the atom corresponding to the \lstinline!input!, \lstinline!output(call(f, 3), 6).!

\subsection{Handling Multiple Arguments}
The interpreter detailed until now only handles single argument functions. Because of the need to evaluate function arguments before evaluating the function call, the interpreter needs some way to evaluate all arguments within the same step. \\ \\
This is solved through the introduction of tuples. More than one program argument is represented as a nested tuple. For example, a function \lstinline!f! with four arguments has form \lstinline!call(f, (A, (B, (C, D))))!. Then, rules to handle evaluation and values of tuples are added. 

\begin{lstlisting}[caption={Tuple rules}, label={lst:tuple_rule}, firstnumber=78]
eval(A) :- eval((A, B)).
eval(B) :- eval((A, B)).

value((A, B), (V1, V2)) :- eval((A, B)), value(A, V1), value(B, V2).
\end{lstlisting}
\mbox{}\\
\ref{lst:tuple_rule} details tuple handling. The eval rules propagate, so when evaluating a tuple you evaluate both halves of the tuple. The value rule states that if you have to evaluate a tuple, then the value of that is a tuple containing the values of both halves of the tuple.

\subsection{Where Rules}
One major optimisation I have implemented is the usage of \lstinline!where! rules. The \lstinline!where! statement in Haskell allows for a variable to be substituted by a defined expression, and in my ASP implementation the semantics are the same. For instance, the factorial program defined in Haskell traditionally as \\

\begin{lstlisting}
factorial x :: Int -> Int
factorial x 
	| x == 0 = 1
	| otherwise = x * f (x - 1)
\end{lstlisting}
\mbox{}\\
Can be alternatively defined as \\

\begin{lstlisting}
factorial x :: Int -> Int
factorial x 
	| x == 0 = 1
	| otherwise = x * x1
	where x1 = f x2
		where x2 = x - 1
\end{lstlisting}
\mbox{}\\
Similarly, these where rules can be encoded as ASP terms in the following way, while \lstinline!match_guard! rules stay the same.\\

\begin{lstlisting}
rule(1, f, 0, 1).
rule(2, f, N, mul(N, x1)).

where(x1, N, call(f, x2)).
where(x2, N, sub(N, 1)).
\end{lstlisting}
\mbox{}\\
To handle these new terms, the existing rules have to be modified. If this were to be implemented naively, then the value of a where variable would be defined using the rule \\

\begin{lstlisting}
value_with(X, Val) :- 
		eval_with(X), 
		where(X, Args,  Expr), 
		value_with(Expr, Val).
\end{lstlisting}
\mbox{}\\
However, the problem with this is that the state of the \lstinline!Args! variable is not known. If the same where variable needs to be evaluated multiple times throughout execution (i.e. through recursive calls), then multiple \lstinline!value! terms appear for the same where variable. For the program above, the returned Answer Set would contain the atoms \\

\begin{lstlisting}
value_with(x1, 2)
value_with(x1, 1)
value_with(x2, 2)
value_with(x2, 1)
\end{lstlisting}
\mbox{}\\
To handle this, I introduce new predicates which keep track of input arguments.

\begin{center}
\begin{tabular}{| c | m{0.6\linewidth} |}
\hline
\textbf{ASP Term} & \textbf{Semantics} \\
\hline
\lstinline!value_with(Expr, Val, Args)! 
&
\mbox{}\newline
Expression value with respect to some \lstinline!Args!. \newline
\\
\hline
\lstinline!eval_with(Expr, Args)! 
&
\mbox{}\newline
Selects \lstinline!Expr! to be evaluated with respect to some \lstinline!Args!. \newline
\\
\hline
\end{tabular}
\end{center}
\mbox{}\\
These new predicates are then used to replace the existing \lstinline!value! and \lstinline!eval! predicates and their corresponding rules. For example, to calculate the value of a multiplication statement, the following rule is added.

\begin{lstlisting}[caption={Second attempt at multiplication}, label={lst:comp_mult}, firstnumber=57]
value_with(mul(A, B), @to_num(V1) * @to_num(V2), Args) :- 
		eval_with(mul(A, B), Args), 
		value_with(A, V1, Args), 
		value_with(B, V2, Args), 
		const_number(@to_num(V1)*@to_num(V2)).
\end{lstlisting}
\mbox{} \\
Similar rules exist for addition and subtraction. Note the use of a lua function \lstinline!@to_num()!, as a bug workaround. This bug throws an error if any in-built arithmetic operations are called without integer operations, and although all values should be integers at this point, an error still occurs. \\ \\
Now I can re-define how to evaluate and calculate the value of a \lstinline!where! variable. \\

\begin{lstlisting}[caption={Handling where evaluation}, label={lst:comp_where_eval}, firstnumber=76]
eval_with(Expr, Args) :- eval_with(X, Args), where(X, Args, Expr).
\end{lstlisting}
\mbox{} \\
\ref{lst:comp_where_eval} states that if you have to evaluate a \lstinline!where! variable then you evaluate the corresponding \lstinline!Expr!. \\
 
\begin{lstlisting}[caption={Handling where values}, label={lst:comp_where_val}, firstnumber=64]
value_with(X, V, Args) :- 
		eval_with(X, Args), 
		where(X, Args, Expr), 
		value_with(Expr, V, Args).
\end{lstlisting}
\mbox{} \\
\ref{lst:comp_where_val} handles values. A \lstinline!where! variable has the value \lstinline!Val! if a corresponding \lstinline!where! rule exists with respect to arguments called. \\

\subsection{Complex and Non-Complex Expressions}

The need to pass around arguments with terms unfortunately had the effect of greatly increasing the number of atoms in the grounding. Each expression to be evaluated can appear multiple times with different combinations of arguments, even if the expression does not depend on the value of those arguments. For example, the value of expressions \lstinline!mul(3, 2)! will always be the same, regardless of input arguments. \\ \\
To handle this, I introduce the idea of ``complex'' and ``non-complex'' expressions. An expression is complex if it contains a where variable, requiring arguments to be passed in. For example, \lstinline!mul(4, x1)! is complex, but \lstinline!mul(4, 2)! is not. \\ \\
This concept of complexity is represented in ASP by the predicates \lstinline!complex! and \lstinline!n_complex!. I will now describe the rules which create these predicates.\\

\begin{lstlisting}[caption={Check for complexity}, label={lst:comp_check}, firstnumber=88]
check_if_complex(Expr) :- eval_with(Expr, _).
\end{lstlisting}
\mbox{} \\
\ref{lst:comp_check} initialises \lstinline!check_if_complex! predicates. If you have to evaluate an expression, you also have to check if it is complex \\

\begin{lstlisting}[caption={Checking propagation}, label={lst:comp_check_prop}, firstnumber=90]
check_if_complex(Args) :- check_if_complex(call(F, Args)).
check_if_complex(A) :- check_if_complex((A, B)).
check_if_complex(B) :- check_if_complex((A, B)).
check_if_complex(A) :- check_if_complex(mul(A, B)).
check_if_complex(B) :- check_if_complex(mul(A, B)).
check_if_complex(A) :- check_if_complex(sub(A, B)).
check_if_complex(B) :- check_if_complex(sub(A, B)).
check_if_complex(A) :- check_if_complex(add(A, B)).
check_if_complex(B) :- check_if_complex(add(A, B)).
\end{lstlisting}
\mbox{} \\
\ref{lst:comp_check_prop} defines propagation of \lstinline!check_if_complex! predicates, similarly to \lstinline!eval_with! propagation. If you have to check that an expression is complex, then you also have to check both sub-expressions\\

\begin{lstlisting}[caption={Complex generation}, label={lst:comp_gen}, firstnumber=100]
complex(x0;x1;x2;x3).

complex((A, B))        :- complex(A), check_if_complex((A, B)).
complex((A, B))        :- complex(B), check_if_complex((A, B)).
complex(mul(A, B))     :- complex(A), check_if_complex(mul(A, B)).
complex(mul(A, B))     :- complex(B), check_if_complex(mul(A, B)).
complex(sub(A, B))     :- complex(A), check_if_complex(sub(A, B)).
complex(sub(A, B))     :- complex(B), check_if_complex(sub(A, B)).
complex(add(A, B))     :- complex(A), check_if_complex(add(A, B)).
complex(add(A, B))     :- complex(B), check_if_complex(add(A, B)).
\end{lstlisting}
\mbox{} \\
\ref{lst:comp_gen} defines propagation of \lstinline!complex! predicates. \\
The base case for a complex term is \lstinline!complex(x0;x1;..;xN)!, where \lstinline!x0, x1, ..., xN! are the possible where variables. Then, if either sub-expression of an expression is complex, then the entire expression is complex. \\

\begin{lstlisting}[caption={Non complex introduction}, label={lst:ncomp_intro}, firstnumber=111]
n_complex(A) :- const(A), check_if_complex(A).
\end{lstlisting}
\mbox{} \\
\ref{lst:ncomp_intro} introduces \lstinline!n_complex! predicates. If a term is a constant, then it is not complex. \\

\begin{lstlisting}[caption={Non complex propagation}, label={lst:ncomp_prop}, firstnumber=113]
n_complex(call(F, Args)) :- n_complex(Args), check_if_complex(call(F, Args)).
n_complex((A, B))        :- n_complex(A), n_complex(B), check_if_complex((A, B)).

n_complex(mul(A, B))     :- 
		n_complex(A), n_complex(B), check_if_complex(mul(A, B)).
n_complex(sub(A, B))     :- 
		n_complex(A), n_complex(B), check_if_complex(sub(A, B)).
n_complex(add(A, B))     :- 
		n_complex(A), n_complex(B), check_if_complex(add(A, B)).
\end{lstlisting}
\mbox{} \\
\ref{lst:ncomp_prop} represents propagation of \lstinline!n_complex! terms. If both sub-expressions of an expression are not complex, that that expression is also not complex. \\ \\
These \lstinline!complex! and \lstinline!n_complex! terms are now used to modify the existing rules. First, \lstinline!eval_with! rules are modified to only propagate when the sub-expression is complex. \\

\begin{lstlisting}[caption={Eval with modification}, label={lst:eval_mod}, firstnumber=78]
eval_with(A, Args) :- complex(A), eval_with((A, B), Args).
eval_with(B, Args) :- complex(B), eval_with((A, B), Args).
eval_with(A, Args) :- complex(A), eval_with(mul(A, B), Args).
eval_with(B, Args) :- complex(B), eval_with(mul(A, B), Args).
eval_with(A, Args) :- complex(A), eval_with(sub(A, B), Args).
eval_with(B, Args) :- complex(B), eval_with(sub(A, B), Args).
eval_with(A, Args) :- complex(A), eval_with(add(A, B), Args).
eval_with(B, Args) :- complex(B), eval_with(add(A, B), Args).
\end{lstlisting}
\mbox{}\\
Next, I re-introduce the \lstinline!value! predicate. This predicate is only generated when the expression to be evaluated is non complex. For example, to calculate the value of a simple multiplication, the following rule is used : 

\begin{lstlisting}[caption={Value with modification}, label={lst:value_mod}, firstnumber=69]
value(mul(A, B), @to_num(V1) * @to_num(V2)) :- 
		const_number(V1), 
		const_number(V2), 
		n_complex(mul(A, B)), 
		value(A, V1), 
		value(B, V2), 
		const_number(@to_num(V1)*@to_num(V2)).
\end{lstlisting}
\pagebreak

\section{A Worked Example : Greatest Common Divisor}

To illustrate the interpreter, I will walk through a simple example - Euclid's algorithm to calculate the Greatest Common Divisor \cite{Euclid}. The Haskell definition of this function is : \\

\begin{lstlisting}
gcd x y
	| x == y = x
	| x > y  = gcd(x - y, y)
	| x < y  = gcd(x, y - x)
\end{lstlisting}
\mbox{} \\
You may notice this is not the typical definition of Euclid's algorithm, as it does not make use of modulo. This is because my current language bias does not support the modulo operator. \\ \\
This Haskell function is represented in ASP as :\\

\begin{lstlisting}
rule(1, gcd, (A, B), A) :- input(call(gcd, (A, B))).

rule(2, gcd, (A, B), call(gcd, (x1, B))) :- input(call(gcd, (A, B))).
where(x1, (A, B), sub(A, B)) :- input(call(gcd, (A, B))).

rule(3, gcd, (A, B), call(gcd, (A, x2))) :- input(call(gcd, (A, B))).
where(x2, (A, B), sub(B, A)) :- input(call(gcd, (A, B))).
\end{lstlisting}
\mbox{} \\
And the corresponding \lstinline{match} rules are :\\ %{

\begin{lstlisting}
match_guard(gcd, 1, (A, B)) :- A == B, input(call(gcd, (A, B))).
match_guard(gcd, 2, (A, B)) :- A > B, input(call(gcd, (A, B))).
match_guard(gcd, 3, (A, B)) :- A < B, input(call(gcd, (A, B))).
\end{lstlisting}

\subsection{A Simple Input}
To start with, I will work through a simple example which matches the base case, \lstinline{gcd(3, 3)}. This input is represented in ASP as the term \lstinline{input(call(gcd, (3, 3)))}, meaning function \lstinline{gcd} is called with \lstinline{(3, 3)} as the arguments. \\ \\
The first predicates generated are related to matching. As \lstinline{(3 == 3)}, the first \lstinline{match_guard} rule is applied and a the term \lstinline{match_guard(gcd, 1, (3, 3))} is added to the output.\\ \\ %{
The rule next applied is \\

\begin{lstlisting}[firstnumber=197]
match(F, Index, Inputs) :- 
		not smaller_match(F, Index, Inputs), 
		rule(Index, F, Inputs, _), 
		match_guard(F, Index, Inputs).
\end{lstlisting}
\mbox{} \\
As the relevant ground \lstinline{rule} and \lstinline{match_guard} terms exist, and there are no smaller matches, (as 1 is the smallest Index), I generate a \lstinline{match(gcd, 1, (3, 3))} term for the output. \\ \\ %{
Next, the tool has to decide what to evaluate, by generating \lstinline{eval_with} terms. The rule applied is :\\ %{

\begin{lstlisting}[firstnumber=128]
eval_with(Expr, Inputs) :- 
		input(call(F, Inputs)), 
		rule(Index, F, Inputs, Expr), 
		match(F, Index, Inputs).
\end{lstlisting}
\mbox{} \\
Because the tool knows the ground \lstinline{rule} term \lstinline{rule(1, gcd, (3, 3), 3)}, it \lstinline{match} that rule with the term \lstinline{match(gcd, 1, (3, 3))} and it knows the \lstinline{input} term \lstinline{input(call(gcd, (3, 3)))}, it can apply this rule and get the expected term, \lstinline{eval_with(3, (3, 3))}, as part of the output. Semantically, this makes sense, as we want to evaluate the body of the called function, with respective arguments. \\ \\%{
Now, the tool can work out values, through application of the rule \\

\begin{lstlisting}[firstnumber=97]
value_with(N, N, Args) :- eval_with(N, Args), const(N).
\end{lstlisting}
\mbox{} \\
The tool just generated the term \lstinline{eval_with(3, (3, 3))}, and it knows that 3 is a constant, so it can output that \lstinline{value_with(3, 3, (3, 3))}. \\ \\
Finally, we can generate output. Using the rule \\

\begin{lstlisting}[firstnumber=55]
output(call(F, Args), Out) :- 
		rule(Index, F, Args, Expr), 
		match(F, Index, Args), 
		value_with(Expr, Out, Args).
\end{lstlisting}
\mbox{} \\
In the same way to earlier rule applications, the tool knows the relevant ground \lstinline{rule(1, gcd, (3, 3), 3)} and \lstinline{match(gcd, 1, (3, 3))} terms, and we just generated the \lstinline{value_with(3, 3, (3, 3))} term. Therefore, the tool can return \lstinline{output(call(gcd, (3, 3)), 3)}, as expected.

\subsection{A More Complex Example}
Now I will detail a more complicated example, where the tool visits where rules and more complicated expressions. As input, I will use \lstinline{gcd(9, 6)}, which is represented in ASP as the term \lstinline{input(call(gcd, (9, 6)))}. \\ \\
Once again, initially the tool generates \lstinline{match} terms using the rule : \\ %{

\begin{lstlisting}[firstnumber=197]
match(F, Index, Inputs) :-
		not smaller_match(F, Index, Inputs), 
		rule(Index, F, Inputs, _), 
		match_guard(F, Index, Inputs).
\end{lstlisting}
\mbox{} \\
This time, it generates the ground term \lstinline{match(gcd, 2, (9, 6))}, as $(9 > 6)$ it hits the second rule guard. It then attempts to determine which rules to evaluate, using the rule : \\ %{

\begin{lstlisting}[firstnumber=128]
eval_with(Expr, Inputs) :- 
		input(call(F, Inputs)), 
		rule(Index, F, Inputs, Expr), 
		match(F, Index, Inputs).
\end{lstlisting}
\mbox{} \\
This rule generates the term \lstinline!eval_with(call(gcd, (x1, 6)), (9, 6))!. This is where is example diverges from the first. We first have to evaluate the arguments, because they are complex. \\ \\
The tool knows these rules are complex because it has checked them. Using this rule : \\

\begin{lstlisting}[firstnumber=149]
check_if_complex(Expr) :- eval_with(Expr, _).
\end{lstlisting}
\mbox{} \\
This rule generates the term \lstinline!check_complex(call(gcd, (x1, 6)))!. Then using the next rule, the tool checks the complexity of the arguments \\

\begin{lstlisting}[firstnumber=151]
check_if_complex(Args) :- check_if_complex(call(F, Args)).
\end{lstlisting}
\mbox{} \\
This then generates the term \lstinline!check_complex((x1, 6))!. It then checks each argument individually, using the rules  \\

\begin{lstlisting}[firstnumber=152]
check_if_complex(A) :- check_if_complex((A, B)).
check_if_complex(B) :- check_if_complex((A, B)).
\end{lstlisting}
\mbox{} \\
Now, the tool knows that \lstinline!x1! is defined as complex, so we can start rebuilding the argument expression as complex. Using the rule  \\

\begin{lstlisting}[firstnumber=163]
complex((A, B))        :- complex(A), check_if_complex((A, B)).
\end{lstlisting}
\mbox{} \\
This tells the tool to include the term \lstinline!complex((x1, 6))!. Now, having checked that the arguments are complex, we can evaluate them, using \\

\begin{lstlisting}[firstnumber=135]
eval_with(Args_new, Args_old) :- 
		complex(Args_new), 
		eval_with(call(F, Args_new), Args_old).
\end{lstlisting}
\mbox{} \\
The tool now knows to \lstinline!eval_with((x1, 6), (9,6))!. To do this, it evaluates all of the complex sub-expressions, using the rule \\ 

\begin{lstlisting}[firstnumber=139]
eval_with(A, Args) :- complex(A), eval_with((A, B), Args).
\end{lstlisting}
\mbox{} \\
This produces the term \lstinline{eval_with(x1, (9, 6))}. Because it has to now evaluate a where variable, it chooses the rule \\ %{

\begin{lstlisting}[firstnumber=133]
eval_with(Expr, Args) :- eval_with(X, Args), where(X, Args, Expr).
\end{lstlisting}
\mbox{} \\
As the body of the where rule referenced by \lstinline{x1} to be \lstinline{where(x1, (A, B), sub(A, B))} is already defined, the tool then takes the ground version of this definition and applies the rule to get the term \lstinline{eval_with(sub(9, 6), (9,6))}. \\ \\%{
This rule is why the tool needs to pass the relevant arguments around as it evaluates terms. If the \lstinline{(9, 6)} was missing, then the tool would not know which ground version of the rule to use.\\ %{
The tool has now reached the end of evaluating, because \lstinline{eval_with(sub(9, 6), (9, 6))} is not complex. In the same way the tool checked for complexity, checking if an expression is not complex relies on \lstinline{check_if_complex} terms. Once again, it uses the rule\\

\begin{lstlisting}[firstnumber=149]
check_if_complex(Expr) :- eval_with(Expr, _).
\end{lstlisting}
\mbox{} \\
Which introduces the term \lstinline{check_if_complex(sub(9, 6))}. As before, this rule then propagates, generating \lstinline{check_if_complex(9)} and \lstinline{check_if_complex(6)} terms. Now, as 9 and 6 are constants, they are not complex, as defined by this rule \\ %{

\begin{lstlisting}[firstnumber=172]
n_complex(A) :- const(A), check_if_complex(A).
\end{lstlisting}
\mbox{} \\
Now the tool knows \lstinline{n_complex(9)} and \lstinline{n_complex(6)}. It then uses the rule \\ %{

\begin{lstlisting}[firstnumber=181]
n_complex(sub(A, B))     :- 
		n_complex(A), 
		n_complex(B), 
		check_if_complex(sub(A, B)).
\end{lstlisting}
\mbox{} \\
Which produces the term \lstinline{n_complex(sub(9, 6))}, as expected. This term can now have its value calculated, as it is not complex. Using the rule \\ %{

\begin{lstlisting}[firstnumber=197]
value(sub(A, B), @to_num(V1) - @to_num(V2)) :- 
		const_number(V1), 
		const_number(V2), 
		n_complex(sub(A, B)), 
		value(A, V1), 
		value(B, V2), 
		const_number(@to_num(V1)-@to_num(V2)).
\end{lstlisting}
\mbox{} \\
This generates the term \lstinline{value(sub(9, 6), 3)}, as it already knows \lstinline{value(9, 9)} and \lstinline{value(6, 6)}, as they are constants. Now, the tool can work out the value of the where variable, \lstinline{x1}, using this rule : \\

\begin{lstlisting}[firstnumber=90]
value_with(X, V, Args) :- 
		eval_with(X, Args), 
		where(X, Args, Expr), 
		value_with(Expr, V, Args).
\end{lstlisting}
\mbox{} \\
This gives the tool the term \lstinline{value_with(x1, 3, (9, 6))}. Now the tool has almost calculated the value of the function call arguments, all it has to do it use this rule \\%{

\begin{lstlisting}[firstnumber=85]
value_with((A, B), (V1, V2), Args) :- 
		eval_with((A, B), Args), 
		value_with(A, V1, Args), 
		value_with(B, V2, Args).
\end{lstlisting}
\mbox{} \\
Which combines the terms \lstinline{value_with(x1, 3, (9, 6))} and \lstinline{value_with(6, 6, (9, 6))}, to get \lstinline{value_with((x1, 6), (3, 6), (9, 6))}. \\ \\ %{
Remember that the overall goal of this was to be able to evaluate the term \lstinline{eval_with(call(gcd, (x1, 6)), (9, 6))}. Now, this is possible as the tool has generated the value of the arguments. The tool applies the following rule \\ %{

\begin{lstlisting}[firstnumber=193]
input(call(F, Inputs)) :- 
		eval_with(call(F, Args_new), Args_old), 
		value_with(Args_new, Inputs, Args_old).
\end{lstlisting}
\mbox{} \\
Which generates a new \lstinline{input(call(gcd, (3, 6)))} term, effectively starting the process again for a new input. This input is processed in a very similar way to the last one, with the only difference being that the third rule is matched, as \lstinline{3 < 6}. This means that the rule body to be evaluated produces the term \lstinline{eval_with(call(gcd, (3, x2)))}. \\ \\%{
Once again, this evaluation proceeds by attempting to calculate the value of the arguments, more specifically the complex one, \lstinline{x2}. Using the definition, \lstinline{where(x2, (A, B), sub(B, A))}, the tool can generate the ground term \lstinline{value_with(x2, 3, (3, 6))}. This term is then combined with the non complex argument to produce the term \lstinline{value_with((3, x2), (3, 3), (3, 6))}. Then, it generates a new input predicate again by applying the rule \\ 

\begin{lstlisting}[firstnumber=193]
input(call(F, Inputs)) :- 
		eval_with(call(F, Args_new), Args_old), 
		value_with(Args_new, Inputs, Args_old).
\end{lstlisting}
\mbox{} \\
Now, we reach the base case, as the input generated is \lstinline{input(call(gcd, (3, 3)))}. As I explained in the first example, this input generates an output term of \lstinline{output(call(gcd, (3, 3)), 3)}. It reaches this conclusion by matching to the base case, which is defined to return the first argument. \\ \\
With this \lstinline{output} term, the tool can now traverse back up the call stack, to compute a final result. By applying the following rule \\ %{

\begin{lstlisting}[firstnumber=79]
value_with(call(F, Args_new), Out, Args_old) :- 
		eval_with(call(F, Args_new), Args_old), 
		output(call(F, Inputs), Out), 
		value_with(Args_new, Inputs, Args_old).
\end{lstlisting}
\mbox{} \\
This allows the tool to generate the term \lstinline{value_with(call(gcd, (3, x2)), 3, (3, 6))}. This then allows me to use the rule : \\%{

\begin{lstlisting}[firstnumber=55]
output(call(F, Args), Out) :- 
		rule(Index, F, Args, Expr), 
		match(F, Index, Args),
		value_with(Expr, Out, Args).
\end{lstlisting}
\mbox{} \\
Which gives a corresponding \lstinline{output} term \lstinline{output(call(gcd, (3, 6)), 3)}. Once again, I can use this output to generate the term \lstinline{value_with(call(gcd, (x1, 6)), 3)}, and then use this term to generate the final \lstinline{output} term, \lstinline{output(call(gcd, (9, 6)), 3)}, as expected! \\ \\%{

\pagebreak

\section{Full code listing}
\lstinputlisting[firstline=55, firstnumber=55]{../ASP/rules.lp}

\pagebreak
%\renewcommand\bibname{{References}}
%\bibliography{References}
%\bibliographystyle{plain}
