\chapter{Method}

\section{A Haskell Interpreter in ASP}

As a way of better understanding how to represent the target language of the tool, my first step was to implement an Interpreter for the simple target language of my tool.

\subsection{Target Language}

Initially, I chose to target a simple sub language of Haskell with the following terms :

\begin{itemize}
\item Addition
\item Subtraction
\item Multiplication
\item Function Calls (including recursion) with any number of arguments.
\item Lists
\end{itemize}

I chose these terms as I felt they were expressive enough to be able to represent sufficiently complicated test examples.\\ \\

\subsection{Program Representation}
To represent a generic Haskell program in ASP, first I had to choose various predicates to represent different parts of the program.\\ \\
For the arithmetic operations present in my target language, I decided to use simple binary predicates. For example, addition is represented by the \lstinline{add(X, Y).} predicate, and subtraction and multiplication follow in the same way. \\ \\
To represent function calls, I have introduced the \lstinline{call(F, Args).} predicate. Here, F is the name of the function being called, and Args represents an (arbitrary length) list of function arguments. \\ \\
Using these predicates, I can represent the Haskell implementation of the recursive factorial program
\lstinputlisting[language=Haskell, firstline=5, lastline=7]{../ASP/examples/factorial_obs.lp}
by the ASP program
\lstinputlisting[language=Prolog, firstline=11, lastline=16]{../ASP/examples/factorial_obs_with_where.lp}
To explain further, each line (or recursive case) of the target Haskell program is represented by with a rule with a \lstinline{rule(Num, FuncName, Input, Output).} predicate in the head. \\ \\
Because of the vast algorithmic complexity of the combinations of arithmetic operations, I was struggling with performance issues. To sufficiently cover the possible program space, the required number of skeleton rules was overwhelming even for comparatively simple programs. \\ \\
As a solution to this issue, I make heavy use of \lstinline{where(Var, Args, Body).} predicates. These "where" predicates are semantically identical to the Haskell equivalent, specifying replacement rules for the given variables in the scope of the rule. \\ \\
For example, in the program above, instead of one rule
\begin{lstlisting}
rule(2, f, N, mul(N, call(f, sub(N, 1)))).
\end{lstlisting}
We instead use
\lstinputlisting[language=Prolog, firstline=12, lastline=16]{../ASP/examples/factorial_obs_with_where.lp}
nesting each operation in its own clause.

\subsection{Evaluating Rules}

The goal of my interpreter is to be able to evaluate these rules with some given input, to get the correct output.

\subsubsection{Internal Predicates}
As part of the interpreter, I have declared a number of my own predicates, some of which it may not be clear what they represent. As such, this section details them in a succinct manner.
 
\begin{itemize}
\item \lstinline{input(Expr)} and \lstinline{output(Expr, Val)} : These predicates represent input and output to the learned function. If a function has some input Expr, then it is expected that there is an output predicate with a matching Expr.
\item 
\end{itemize}

Because we are interpreting Functional Programs we can be sure each input has one output.

\lstinputlisting[language=Prolog, firstline=58, lastline=58]{../ASP/rules.lp}

This rule generates output predicates if there is a rule that best matches the given arguments, and the output of that rule has a known value.

\lstinputlisting[language=Prolog, firstline=60, lastline=65]{../ASP/rules.lp}

These rules handle calculating the value of expressions. The eval() predicate is generated whenever you need to calculate the value of an expression.

\lstinputlisting[language=Prolog, firstline=67, lastline=76]{../ASP/rules.lp}

These rules handle which expressions to calculate values for. The most important rule here is to top one, which says that whenever you have an input to some matching rule then you need to evaluate the output of that rule.

\lstinputlisting[language=Prolog, firstline=78, lastline=78]{../ASP/rules.lp}

This rule generates more input predicated if we have to calculate the value for a call to a function. This allows us to then generate more ground rule predicates and repeat.

\lstinputlisting[language=Prolog, firstline=80, lastline=81]{../ASP/rules.lp}

These rules allow us to match to the most fitting rule. A rule matches some arguments if there is no smaller rule that also matches those arguments. The match2() predicate is there as a placeholder, and will have effect when more complicated matching (e.g guards) will be needed.

\section{Initial Learning}

I decided to base my (initial) learning task as an ASP encoding similar to ASPAL, with the goal to learn the correct rule() predicates given a number of input/output example pairs:

\begin{itemize}
\item My background knowledge is simply my interpreter from 2.1.2
\item I characterised the Skeleton Rules as a choice rule where there can be up to a given number of rule predicates with an expression that is structured correctly. 
\lstinputlisting[language=Prolog, firstline=41, lastline=41]{../ASP/rules.lp}
\item I then add a constraint to remove any answer sets which do not produce the correct output against the given examples.
\lstinputlisting[language=Prolog, firstline=39, lastline=39]{../ASP/rules.lp}
\end{itemize}

Not described here are my set of Skeleton Rules relating to valid arguments and valid expressions because they simply describe what is defined as valids (as per the Haskell syntax) and I did not deem it important to include here.\\

Currently I can only learn very simple functions (without variables) because of errors in my Interpreter, relating to the ground rule predicates that are generated. However this should not be too difficult to fix. 

\pagebreak
%\renewcommand\bibname{{References}}
%\bibliography{References}
%\bibliographystyle{plain}