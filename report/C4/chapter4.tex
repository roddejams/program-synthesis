\chapter{A Second Approach : Constraint Based Learning}

As seen in the previous chapter, my initial approach suffered from significant difficulty scaling. Even simple two argument functions took upwards of 130 seconds to complete. This was mainly due to the sheer size of the ground learning task, and the complexity from combinations of rule and where predicates.

\section{Top Down Vs. Bottom Up}
The main issue with the interpreted approach is that it is bottom-up. To learn the output of a rule, we must first iterate down the expression tree, calculate the value of each simple sub-expression, then iterate back up the tree combining values until we know a value for the entire rule body. My second approach overcomes this issue by implementing a top down approach. \\ \\
The idea behind this new approach is simple. By maintaining an "equality constraint", I keep track of what each expression is supposed to be equal to (as defined by the input examples). Then, as the program iterates down the expression tree, it fails if it ever finds some easily provable equality failure, i.e 1 == 2. \\ \\
For example, if I know that \lstinline{call(f, 2) == 5} and that the body of function f is \lstinline{2*X + 1}, then I can deduce that 
\begin{align*}
(2*2) + 1 &== 5 \\
(2*2) &== 4 \\
2 &== 2
\end{align*}
So there are no contradictions. \\ \\
However, if instead we have an example stating that \lstinline{call(f, 2) == 6}, with the same function, then instead we get %{
\begin{align*}
(2*2) + 1 &== 6 \\
(2*2) &== 5 \\
\end{align*}
Which fails because 5 is not a multiple of 2.

\subsection{Dealing with termination}
One issue with this new approach is that it does not automatically handle programs which do not terminate. Whilst these programs do not stop clingo from finding a solution, they are incorrect as the constraint is never met. \\ \\
To deal with this, I have to check input examples for termination. While this is typically an undecidable problem, for my small target language it is decidable and computable. To represent this in ASP, I first needed a way to represent the next step of execution of an expression. For example, I can say that \lstinline{next_step(add(1, mul(2, 3)), mul(2, 3))}, meaning that I next evaluate mul(2, 3). \\ \\%{
I then define termination as :
\begin{itemize}
\item If an expression is simple, containing only constants, then it terminates.
\item If the next step of an expression terminates, then that expression also terminates.
\end{itemize}

This approach is fairly efficient as it as another top down approach, and generates a similar number of rules in the ground program as the constraint checking rules.

\section{ASP Representation}
I represent this approach using the following ASP predicates.

\begin{itemize}
\item \lstinline{eq(Expr, Val)} represents an equality. Expr, when evaluated, should equal Val.
\item \lstinline{is_call(call(F, Expr)} represents if a function is called. Used to generate more ground skeleton rules.
\item \lstinline{terminates(Expr)} represents if an expression terminates.
\item \lstinline{next_step(A, B)} represents that B is the expression executed after executing A.
\end{itemize}
%\end{lstlisting}
Now, I use these predicates in the following rules. \\

\lstinputlisting[language=Prolog, firstline=35, lastline=35]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule generates initial equality constraints given by the examples.  \\

\lstinputlisting[language=Prolog, firstline=36, lastline=36]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule constrains equality on constants. The tool should fail if two different constants are equal. \\

\lstinputlisting[language=Prolog, firstline=37, lastline=40]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
These constraints handle edge cases when dealing with multiplication. If multiplying any expression by 0, then it should be equal to 0, and if multiplying two things together, then the answer should be a multiple of them both. \\

\lstinputlisting[language=Prolog, firstline=43, lastline=43]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This constraint handles termination. The tool fails if an input example does not terminate.\\

\lstinputlisting[language=Prolog, firstline=45, lastline=45]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule generates \lstinline{is_call} predicates, which are used to generate more ground instances of skeleton rules. \\ %{

\lstinputlisting[language=Prolog, firstline=47, lastline=47]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule handles propagation of equality constraints through function calls. If a called function is equal to some value, then the body of the function (with correct arguments) is also equal to that value. \\

\lstinputlisting[language=Prolog, firstline=48, lastline=53]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
These rule specify generation of equality predicates with arithmetic, through use of the opposite operations. Addition terms in the head of the rule are necessary to handle edge cases such as division by zero. \\

\lstinputlisting[language=Prolog, firstline=59, lastline=60]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
These rules define termination, as described above. If an expression is a constant, then it terminates, or if the next step of an expression terminates then that expression also terminates. \\

\lstinputlisting[language=Prolog, firstline=62, lastline=62]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule generates the initial \lstinline{next_step} predicates. If there exists an example input, then it is the next step of some arbitrary term \lstinline{e}. \\

\lstinputlisting[language=Prolog, firstline=73, lastline=73]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule exists to reduce the grounding. If any expression is a next step, we generate an \lstinline{is_next_step} predicate, used in the remaining \lstinline{next_step} rules.

\lstinputlisting[language=Prolog, firstline=63, lastline=63]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
This rule handles the next step of function calls. The next step of a function call is the body of that function.

\lstinputlisting[language=Prolog, firstline=64, lastline=69]{../ASP/eq/eq_rules.lp} 
\mbox{} \\
These rules generate \lstinline{next_step} predicates for arithmetic. The next step of an arithmetic expression is the argument that is not constant. //%{ 

\section{Learning}
The actual learning task operates in a similar way to my initial approach. By enumerating all possible rule bodies, I can use a choice rule to try generating answer sets with each one, keeping the answer sets which are satisfiable. However, because I am no longer using 


\section{Performance}



\pagebreak
%\renewcommand\bibname{{References}}
%\bibliography{References}
%\bibliographystyle{plain}