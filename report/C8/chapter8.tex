\chapter{Learning from Examples}

This chapter will detail how I use the interpreter discussed in chapter 3 to perform learning. The tool enumerates all possible rules, then chooses the ones which cover all of the examples.

\section{Additional Rules}
Together with my interpreter, I need the following addition predicates and rules :
\begin{itemize}
\item \lstinline{example(Input, Output)} : This predicate represents an Input / Output pair.
\item \lstinline{choose(R, N)} and \lstinline{choose_where(N)} : These predicates represent the choice of a rule, with depth R, that covers all of the examples.
\item \lstinline{input(In) :- example(In, _).} : This rule generates the initial inputs for my interpreter.
\item \lstinline{:- not output(In, Out), example(In, Out).}  : This constraint represents that you cannot have an example which does not produce a matching output. In other words, this rule rule will removes rules which do not cover the examples.
\end{itemize}
%\end{lstlisting}

\section{Skeleton Rules}
To know what rules are possible to learn, I enumerate all possible combinations of rules, to provide a set for the learning task to choose from. While it may seem that the possible search space is very large, this is only partly true, due to the optimisations allowed by use of \lstinline{where} clauses. \\ \\ %{
Each skeleton rule has one of the following formats: \\

\lstinline{rule(R, F, Args, Expr) :- input(call(f, Args)), choose(R, N).} %{
\mbox{} \\

\lstinline{where(Var, Args, Expr) :- input(call(f, Args)), choose_where(N).} %{
\mbox{} \\ \\
Where \lstinline{Expr} is one of the possible rule bodies. %{

\subsection{Choice Rules}
To run the interpreter on all possible rule combinations, I make use of ASP choice rules. For example, the statement :

\lstinputlisting[language=Prolog, firstline=47, lastline=50]{../ASP/skeleton_rules/own_rules_1arg.lp}
\mbox{} \\
Represents the learning task choosing exactly one of the skeleton rules for each of the possible program rules (or recursive case). Additionally, I need a choice rule for every potential where rule : 

\lstinputlisting[language=Prolog, firstline=52, lastline=55]{../ASP/skeleton_rules/own_rules_1arg.lp}
\mbox{} \\
Here, it is not guaranteed for a where rule to be chosen, as they may not all be necessary in different learning tasks. 

\subsection{Rule combinations}
The depth of the search space is reliant on three main factors : number of arguments, range of allowable constants and target language complexity. My initially small target language means that I only have to enumerate over addition, subtraction, multiplication and function calls, but as I add more expressions (i.e boolean functions), the size of the skeleton rules increases respectively. \\ \\
Similarly, the number of arguments of the target function increases as I have to enumerate all possible pairs. For example, for a simple predicate like addition I need to include : (where X, Y are arguments, C is an arbitrary learned constant, and x1 and x2 are where variables) 

\begin{multicols}{2}
\begin{itemize}
\item \lstinline{add(X, X)}
\item \lstinline{add(X, Y)}
\item \lstinline{add(X, C)}
\item \lstinline{add(X, x1)}
\item \lstinline{add(X, x2)}
\item \lstinline{add(Y, Y)}
\item \lstinline{add(Y, C)}
\item \lstinline{add(Y, x1)}
\item \lstinline{add(Y, x2)}
\item \lstinline{add(C, x1)}
\item \lstinline{add(C, x2)}
\item \lstinline{add(x1, x2)}
%\end{lstlisting}
\end{itemize}
\end{multicols}

Even in this simple example, there are 12 possible rules. As addition is commutative, I have omitted any rules where the ordering is reversed. More optimisations like this can be seen in the next section.
A full list of the skeleton rules generated for both one and two argument functions can be seen in the appendix.

\subsection{Learning Match Rules}


\section{Multiple Solutions and Optimisation}
While learning, it is not uncommon to have multiple solutions, usually due to multiple semantically equivalent base cases. I may get two answer sets as output, one having learned \lstinline{rule(1, F, 0, 1)}, and the other with \lstinline{rule(1, F, 0, 0+1)}. \\ \\
To attempt at dealing with this, I have implemented a basic optimisation system, by prioritising rules with shorter bodies. In general, rules with lower rule number are shorter, so I used the minimisation rule :

\lstinputlisting[language=Prolog, firstline=63, lastline=63]{../ASP/skeleton_rules/own_rules_1arg.lp}
\mbox{}\\
Which prioritises rules with lower rule numbers.\\ \\
As a second optimisation, I wanted to prefer less complicated results, and answer sets with fewer \lstinline{where} clauses represent less complicated functions, as the depth of the function is lower. Because of this, I use the minimisation rule : %{

\lstinputlisting[language=Prolog, firstline=64, lastline=64]{../ASP/skeleton_rules/own_rules_1arg.lp}
\mbox{}\\

\section{A Worked Example : Learning GCD}
In the last chapter, I went through the steps that the interpreter takes to produce results when given Euler's algorithm to calculate the greatest common divisor. In this section, I will detail how I then learn that program. As a reminder, this function is defined in Haskell as :

\begin{lstlisting}
gcd x y
	| x == y = x
	| x > y	 = gcd (x - y) y
	| x < y	 = gcd x (y - x)
\end{lstlisting}
\mbox{}\\
As input to the learning task I need to specify some examples. I chose the examples 

\lstinputlisting[language=Prolog, firstline=32, lastline=36]{../ASP/eq/gcd.lp}
\mbox{}\\
Because they seem to cover all of the cases I need to learn. \\ \\
In addition to this, I will need to enumerate all of the possible \lstinline{rule} and \lstinline{where} bodies as part of the skeleton rules. I will not list the entire set of skeleton rules here, but instead highlight some which will be in use later : 

TODO: Put skeleton rules in here.

After running the learning task with these inputs, I get as output the terms :

TODO: Put uncomplete output here.

These rules represent the learned Haskell program:

TODO: Put haskell here.

What is interesting is that this is not a correct implementation of Euler's algorithm! However, this result is still returned as it covers all of the examples. For example, the example \lstinline{example(call(gcd, (9, 6)), 3)} generates a \lstnline{input(call(gcd, (9, 6)))} term. This term is then ran through the interpreter with the chose rules, and returns \lstinline{output(call(gcd, (9, 6)), 3)}. As this does not contradict the example, those rules are valid. \\ \\%{
As an attempt to fix this problem, I can add some extra examples. By adding these two examples :\\

\lstinputlisting[language=Prolog, firstline=37, lastline=38]{../ASP/eq/gcd.lp}
\mbox{}\\
These examples are cases where the previous result would not work, and help generalise the target function. \\ \\
After running these examples as input, I get the following terms as a result :

TODO: Add terms

These terms translate to the haskell program :

TODO: Add Haskell

As required.

\section{Performance Issues}
Unfortunately, this learning task suffers from extreme difficulty scaling. While the number of skeleton rules is relatively small, the problem comes when considering combinations of \lstinline{rule} and \lstinline{where} terms.\\ \\ %Add specific maths here?%
For the example described above, the output ground program is over _ lines long, and takes 

\pagebreak
%\renewcommand\bibname{{References}}
%\bibliography{References}
%\bibliographystyle{plain}