fmod SUBPROGRAMS is
	inc HYPOTHESES .
	inc SHARED-SUB .
	
	sort SubIntroResult .
	op <_,_,_,_,_,_,_> : KeySet Bool RuleDataSet Nat
		IODataSet Nat IOSet -> SubIntroResult [ctor] .
		
	sorts SubnamesResult .
	op <_,_> : IndexNamePairSet Nat -> SubnamesResult .	*** Subnames and FC
	
	***sort CallRelUpdateResult .
	***op <_,_,_> : QidPairSet QidPairSet QidPairSet -> CallRelUpdateResult [ctor] .
	
	
	vars RKey DKey RC UpdRC ResultRC DC UpdDC ResultDC EC FC UpdFC EKey 
		 Index Index2 Index3 VarIndex Speci : Nat .
	var Progs : ProgramSet .
	vars Name Name1 Name2 Subname Subname2 Root : Qid .
	var V : Variable .
	vars Matchable Names CNames : FunNameSet .
	vars Rules UpdRules ResultRules : RuleDataSet .
	vars IOSubsets UpdIOSubsets ResultIOSubsets : IODataSet .
	var IOSubset : IOData .
	vars Expls UpdExpls ResultExpls : IOSet .
	var Coas : Coarities .
	vars RHS Subterm I O : Term .
	vars RKeys SubRKeys EKeys Indices : KeySet .
	vars Finished SubFinished FragFinished : Bool .
	vars Subterms Inputs : TermList .
	var InData : AUResult .
	var Matches : MatchDataSet .
	var ODS : OutDataSet .
	var Preds : TermList .
	vars Parts PParts : Partitions .
	var Sub : SubData .
	var Subnames : IndexNamePairSet .
	vars Cs UpdCs : CallPairSet .
	var SD : SubstitutionData .
	var NOs : NamedOutputs .
	var Calls : Callclass .
	vars INPS Depth : IndexNamePairSet .
	var D : Nat .
	var Cond : EqCondition .
	
	op subprograms : Nat InductionState Coarities -> InductionState .	

	*** if RHS is a variable, no subprograms can be introduced, just exclude programs
	*** containing RKey
	eq subprograms(RKey, 
				   istate(Progs, 
				   		  (rule(RKey, Name, DKey, V, Matchable, noSubData, Matches, false) , Rules),
		       	      	  RC, IOSubsets, DC, Expls, EC, FC, Depth), 
				   Coas) =
		istate(empty, 
			   (rule(RKey, Name, DKey, V, Matchable, noSubData, Matches, false) , Rules),
			   RC, IOSubsets, DC, Expls, EC, FC, Depth) .
	
	*** subproblems has already been introduced, just integrate Subdata
	eq subprograms(RKey,
				   istate(Progs, 
						  (rule(RKey, Name, DKey, RHS, Matchable, < RKeys , Names , SubFinished >, Matches, false) , 
						   Rules), 
						  RC, IOSubsets, DC, Expls, EC, FC, Depth), 
				   Coas) =
		istate(integrateSubData(RKey, Name, < RKeys , Names , SubFinished >, Rules, Progs),
			   (rule(RKey, Name, DKey, RHS, Matchable, < RKeys , Names , SubFinished >, Matches, false) , 
			    Rules), 
			   RC, IOSubsets, DC, Expls, EC, FC, Depth) .
	
	*** RHS consists of a root and subterms incl. free variables
	ceq subprograms(RKey,  
					istate(Progs, 
						   (rule(RKey, Name, DKey, Root [ Subterms ], Matchable, noSubData, Matches, false) , 
							Rules), RC, 
					  	   (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   Cond, Preds, Parts, PParts) , 
						   	IOSubsets),
						   DC, Expls, EC, FC, Depth),
					 Coas) =
		istate(integrateSubData(RKey, Name, Sub, Rules, Progs), 
		       (rule(UpdRC, Name, DKey, Root [ newSubterms(Subterms, Subnames, 1, Inputs) ], Matchable, noSubData, empty, true) , 
		        rule(RKey, Name, DKey, Root [ Subterms ], Matchable, Sub, Matches, false) , 
				UpdRules), s UpdRC,
		       UpdIOSubsets, UpdDC, UpdExpls, EC, UpdFC, Depth)
		if not((Depth contains Name)) /\
		   < Subnames , UpdFC > := createIndexSubnamePairs(Indices, Subterms, < empty , FC >) /\
		   < RKeys , SubFinished , UpdRules , UpdRC , UpdIOSubsets , UpdDC , UpdExpls > :=
		   	introduceSubproblems(Subnames, Name, Matchable, EKeys, Rules, RC, 
					     		 (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   		 (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   		 Cond, Preds, Parts, PParts) , 
						   		  IOSubsets), DC, Expls, Coas) /\
		   Sub := < (UpdRC , RKeys) , getNames(Subnames) , SubFinished > .
		   
		   
	*** RHS consists of a root and subterms incl. free variables
	ceq subprograms(RKey,  
					istate(Progs, 
						   (rule(RKey, Name, DKey, Root [ Subterms ], Matchable, noSubData, Matches, false) , 
							Rules), RC, 
					  	   (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   Cond, Preds, Parts, PParts) , 
						   	IOSubsets),
						   DC, Expls, EC, FC, (< D : Name > , Depth)),
					 Coas) =
		istate(integrateSubData(RKey, Name, Sub, Rules, Progs), 
		       (rule(UpdRC, Name, DKey, Root [ newSubterms(Subterms, Subnames, 1, Inputs) ], Matchable, noSubData, empty, true) , 
		        rule(RKey, Name, DKey, Root [ Subterms ], Matchable, Sub, Matches, false) , 
				UpdRules), s UpdRC,
		       UpdIOSubsets, UpdDC, UpdExpls, EC, UpdFC, (createDepth(D, getNames(Subnames)) , < D : Name > , Depth))
		if D < 3 /\
		   < Subnames , UpdFC > := createIndexSubnamePairs(Indices, Subterms, < empty , FC >) /\
		   < RKeys , SubFinished , UpdRules , UpdRC , UpdIOSubsets , UpdDC , UpdExpls > :=
		   	introduceSubproblems(Subnames, Name, Matchable, EKeys, Rules, RC, 
					     		 (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   		 (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   		 Cond, Preds, Parts, PParts) , 
						   		  IOSubsets), DC, Expls, Coas) /\
		   Sub := < (UpdRC , RKeys) , getNames(Subnames) , SubFinished > .
		   
		   
	*** RHS consists of a root and subterms incl. free variables
	ceq subprograms(RKey,  
					istate(Progs, 
						   (rule(RKey, Name, DKey, Root [ Subterms ], Matchable, noSubData, Matches, false) , 
							Rules), RC, 
					  	   (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   Cond, Preds, Parts, PParts) , 
						   	IOSubsets),
						   DC, Expls, EC, FC, (< D : Name > , Depth)),
					 Coas) =
		istate(empty, 
						   (rule(RKey, Name, DKey, Root [ Subterms ], Matchable, noSubData, Matches, false) , 
							Rules), RC, 
					  	   (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , VarIndex >, 
						   	 	   (< Name , Root [ Subterms ] , Indices , false > , ODS), 
						   	 	   Cond, Preds, Parts, PParts) , 
						   	IOSubsets),
						   DC, Expls, EC, FC, (< D : Name > , Depth))
		if D >= 3 .
		   	   
		   
		   
	op getNames : IndexNamePairSet -> FunNameSet .
	eq getNames(empty) = noName .
	eq getNames((< Index : Subname > , Subnames)) = 
		Subname * getNames(Subnames) .
		   
	op newSubterms : TermList IndexNamePairSet Nat TermList -> TermList .
	eq newSubterms(empty, Subnames, Index, Inputs) = empty .
	eq newSubterms((Subterm , Subterms), (< Index : Subname > , Subnames), Index, Inputs) =
		Subname [ Inputs ] , newSubterms(Subterms, Subnames, s Index, Inputs) .
	eq newSubterms((Subterm , Subterms), Subnames, Index, Inputs) =
		Subterm , newSubterms(Subterms, Subnames, s Index, Inputs) [owise] .
		
		   
	op integrateSubData : Nat Qid SubData RuleDataSet ProgramSet -> ProgramSet .
	eq integrateSubData(RKey, Name, < SubRKeys , Names , SubFinished >, Rules,
			    (prog((RKey , RKeys), Cs, Speci, CNames, Finished) , Progs)) =
		integrateSubData(RKey, Name, < SubRKeys , Names , SubFinished >, Rules, 
				 (prog((SubRKeys , RKeys), 
				 	   updCalls(Name, Names, Cs, empty),
				 	   *** *(Speci + (numberOf Names in CNames)), 
				 	   *** i think the subprograms can't already exist in the program,
				 	   *** ie, Speci remains unchanged
				 	   Speci,
				 	   CNames, finished(RKeys, getRules(RKeys, Rules)) and SubFinished) ,
				  Progs)) .
		***if < UpdCallRed , UpdCallEq , UpdCallInc > := 
		***	updateCallRelations(Name, Names, CallRed, CallEq, CallInc, empty, empty, empty) .
	eq integrateSubData(RKey, Name, Sub, Rules, Progs) = Progs [owise] .
		
	
	
	*** op updCallEq : Qid FunNameSet QidPairSet QidPairSet -> QidPairSet .
	*** eq updCallEq(Name1, Names, ((Name2 calls Name1) , CallEq), UpdCallEq) =
	***	updCallEq(Name1, Names, CallEq, 
	*** *			  ((Name2 calls Name1) , createCalls(Name2, Names) , UpdCallEq)) .
	*** eq updCallEq(Name1, Names, CallEq, UpdCallEq) = 
	*** *	(createCalls(Name1, Names) , UpdCallEq) [owise] .
	
	*** op updCallOthers : Qid FunNameSet QidPairSet QidPairSet -> QidPairSet .
	*** eq updCallOthers(Name1, Names, ((Name2 calls Name1) , CallOthers), UpdCallOthers) =
	***	updCallOthers(Name1, Names, CallOthers, 
	*** *				  ((Name2 calls Name1) , createCalls(Name2, Names) , UpdCallOthers)) .
	*** eq updCallOthers(Name1, Names, CallOthers, UpdCallOthers) = 
	***	UpdCallOthers [owise] .
	
	***op updateCallRelations : Qid FunNameSet QidPairSet QidPairSet QidPairSet CallRelUpdateResult
	***	-> CallRelUpdateResult .
	***eq updateCallRelations(Name1, Names, ((Name2 calls Name1) , CallRed), CallEq, CallInc, 
	***					   < UpdCallRed , UpdCallEq , UpdCallInc >) =
	***	updateCallRelations(Name1, Names, CallRed, CallEq, CallInc, 
	***						< ((Name2 calls Name1) , createCalls(Name2, Names) , UpdCallRed) ,
	***						  UpdCallEq , UpdCallInc >) .
	***eq updateCallRelations(Name1, Names, CallRed, ((Name2 calls Name1) , CallEq), CallInc, 
	***					   < UpdCallRed , UpdCallEq , UpdCallInc >) =
	***	updateCallRelations(Name1, Names, CallRed, CallEq, CallInc, 
	***						< UpdCallRed ,
	***	*					  ((Name2 calls Name1) , createCalls(Name2, Names) , UpdCallEq) , 
	***						  UpdCallInc >) .
	***eq updateCallRelations(Name1, Names, CallRed, CallEq, ((Name2 calls Name1) , CallInc), 
	***					   < UpdCallRed , UpdCallEq , UpdCallInc >) =
	***	updateCallRelations(Name1, Names, CallRed, CallEq, CallInc, 
	***						< UpdCallRed , UpdCallEq) , 
	*** *						  ((Name2 calls Name1) , createCalls(Name2, Names) , UpdCallInc) >) .
	***eq updateCallRelations(Name1, Names, CallRed, CallEq, CallInc, 
	***					   < UpdCallRed , UpdCallEq , UpdCallInc >) =
	***	< UpdCallRed ,
	***	*  (createCalls(Name1, Names) , UpdCallEq) , 
	***	  UpdCallInc > [owise] .
		  
	
		   
	op createIndexSubnamePairs : KeySet TermList SubnamesResult -> SubnamesResult .
	eq createIndexSubnamePairs(empty, Subterms, < Subnames , FC >) = < Subnames , FC > .
	eq createIndexSubnamePairs((Index , Indices), Subterms, < empty , FC >) =
		createIndexSubnamePairs(Indices, Subterms, < < Index : createSubname(FC) > , s FC >) .
	ceq createIndexSubnamePairs((Index , Indices), Subterms, < (< Index2 : Subname > , Subnames) , FC >) =
		if INPS =/= empty
		then createIndexSubnamePairs(Indices, Subterms, 
			< (< Index : getSubname(INPS) > , < Index2 : Subname > , Subnames) , FC >) 
		else createIndexSubnamePairs(Indices, Subterms, 
			< (< Index : createSubname(FC) > , < Index2 : Subname > , Subnames), s FC >) 
		fi 
		if INPS := getExistSubnamePair(getNthTerm(Index, Subterms), Subterms, 
									   (< Index2 : Subname > , Subnames)) .
		
	op getExistSubnamePair : Term TermList IndexNamePairSet -> IndexNamePairSet .
	eq getExistSubnamePair(Subterm, Subterms, empty) = empty .
	eq getExistSubnamePair(Subterm, Subterms, (< Index : Subname > , Subnames)) =
		if getNthTerm(Index, Subterms) == Subterm
		then < Index : Subname > 
		else getExistSubnamePair(Subterm, Subterms, Subnames)
		fi .
	
	op getSubname : IndexNamePairSet -> Qid .
	eq getSubname(< Index : Subname >) = Subname .
	
	op introduceSubproblems : IndexNamePairSet Qid FunNameList KeySet 
		RuleDataSet Nat IODataSet Nat IOSet Coarities -> SubIntroResult .
		
	eq introduceSubproblems(empty, Name, Matchable, EKeys, Rules, RC, 
							IOSubsets, DC, Expls, Coas) =
		< empty , true , Rules , RC , IOSubsets , DC , Expls > .
		
	ceq introduceSubproblems((< Index : Subname > , Subnames), Name, Matchable, 
							 EKeys, Rules, RC, IOSubsets, DC, Expls, Coas) =
		< (RKey , RKeys) , Finished and FragFinished , ResultRules , ResultRC , 
		  ResultIOSubsets , ResultDC , ResultExpls >   
		if UpdExpls := introduceOutputs(EKeys, Index, Subname, Name, Expls) /\
		   < DKey , 
		   	 (ioData(DKey, EKeys, InData, ODS, nil, Preds, Parts, PParts) , UpdIOSubsets) , 
		   	 UpdDC > :=
		   	introduceIOData(DC, EKeys, UpdExpls, Coas, IOSubsets) /\
		   < RHS , Finished , IOSubset > :=
			introduceOutData(Subname, 
							 ioData(DKey, EKeys, InData, ODS, nil, Preds, Parts, PParts),
							 UpdExpls, Coas) /\
		   < RKey , UpdRules , UpdRC > :=
		   	introduceRule(RC, Subname, DKey, RHS, (Matchable * Subname), Finished, Rules) /\
		   < RKeys , FragFinished , ResultRules , ResultRC , 
		     ResultIOSubsets , ResultDC , ResultExpls > :=
		   	introduceSubproblems(Subnames, Name, Matchable, EKeys, UpdRules, UpdRC, 
		   						 (IOSubset , UpdIOSubsets), UpdDC, UpdExpls, Coas) .
		
	op introduceOutputs : KeySet Nat Qid Qid IOSet -> IOSet .
	eq introduceOutputs(empty, Index, Subname, Name, Expls) = Expls .
	eq introduceOutputs((EKey , EKeys), Index, Subname, Name, 
						(ioEntry(EKey, I, (< Name , Root [ Subterms ] > , NOs)) , Expls)) =
		introduceOutputs(EKeys, Index, Subname, Name, 
						 (ioEntry(EKey, I, 
						 		  (< Subname , getNthTerm(Index, Subterms) > ,
						 		   < Name , Root [ Subterms ] > , NOs)) ,
						  Expls)) .
endfm
