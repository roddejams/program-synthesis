

*** operator attributes (metadata); if an attrib is not stated, then its
*** negation is executed:
*** "induce":	the function will be generalized
*** "nomatch":	the function will not be matched/called (except as predicate)
*** "pred":		the function can be used as predicate

load /home/martin/benchmark/Progs/Igor2/TermExtensions/terms.maude .
load /home/martin/benchmark/Progs/Igor2/TermExtensions/antiunification.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/general.maude .
***load /home/martin/benchmark/Progs/Igor2/IGOR2.2/preprocessing.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/shared.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/partitioning.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/matching.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/subprograms.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/predicates.maude .
load /home/martin/benchmark/Progs/Igor2/IGOR2.2/examples.maude .



*** sets up the initial induction state
fmod SETUP is
	inc HYPOTHESES .
	inc GENERAL-CONSTANTS .
	*** inc VARIABALIZE .
	
	sort InductionData .
	op idata : Program RuleDataSet Nat IODataSet Nat IOSet Nat Nat OpDeclSet Coarities ->
			*** initial program, init. rules, init. RC, init. IO subsets, init. DC, 
			*** init. examples, init. EC, FC, operators which can be used as preds, 
			*** coarities of constructors
		InductionData .
		
	sort ExplsResult .
	op <_,_,_> : IOSet Nat InitEKeySets -> ExplsResult [ctor]  .
	
	sort RuleDataResult .
	op <_,_,_,_> : RuleDataSet Nat IODataSet Nat -> RuleDataResult [ctor] .
		
	sort InitEKeySets .
	subsort AnnoteKeySet < InitEKeySets .
	op none : -> InitEKeySets [ctor] .
	op __ : InitEKeySets InitEKeySets -> InitEKeySets 
			[ctor assoc comm id: none] .
	eq A:AnnoteKeySet A:AnnoteKeySet = A:AnnoteKeySet .
	
	
	var Ty : Type .
	var TyL : TypeList .
	var Ops : OpDeclSet .
	var Eqs : EquationSet .
	var Mod : Module .
	vars Expls UpdExpls Expls2 VarExpls : IOSet .
	vars EC UpdEC VarEC EKey DC UpdDC DKey RC RKey Speci : Nat .
	var Name : Qid .
	var Input : TermList .
	vars I O Output In RHS : Term .
	vars Attribs Attribs1 Attribs2 : AttrSet .
	var Outs : NamedOutputs .
	var Sigma : Substitution? .
	vars IOSubsets UpdIOSubsets : IODataSet .
	vars IOSubset UpdIOSubset : IOData .
	var EKeys RKeys VarEKeys : KeySet .
	vars AnnEKeys UpdAnnEKeys : InitEKeySets .
	var Rules : RuleDataSet .
	var Coas : Coarities .
	var Prog : Program .
	vars Finished PFinished RFinished : Bool .
	var Matchable CNames IndNames MatchNames : FunNameSet .
	var ODS : OutDataSet .
	***var Preds : TermList .
	var Parts : Partitions .
	var InData : AUResult .
	var IndParams : String .
	var Matches : MatchDataSet .
	
	
	op setupInductionData : Module OpDeclSet EquationSet -> InductionData .
	ceq setupInductionData(Mod, Ops, Eqs) =
		idata(setupProg(prog(empty, empty, 0, noName, true), Rules), 
			  Rules, RC, IOSubsets, DC, Expls, EC, initFC, setupPredOps(Ops), Coas)
		if Coas := getCoas(Ops) /\
		   Matchable := setupMatchable(Ops) /\
		   < Expls , EC , AnnEKeys > := 
		   	setupExpls(Mod, Eqs, setupInduce(Ops), Matchable, empty, initEC, none) /\
		   ***< VarExpls , VarEC , VarEKeys > :=
		   ***	compVariabalizedExpls(Expls, EC, setupInduce(Ops), Ops, Coas) /\
		   < Rules , RC , IOSubsets , DC > := 
			setupRuleDataSet(AnnEKeys, empty, initRC, empty, initDC, Expls,
							 Matchable, Coas) .
			***setupRuleDataSet(< VarEKeys ; setupInduce(Ops) >, empty, initRC, 
			***				 empty, initDC, VarExpls,
			***				 Matchable, Coas) .
	
	op setupProg : Program RuleDataSet -> Program .
	eq setupProg(Prog, empty) = Prog .
	eq setupProg(prog(RKeys, empty, Speci, CNames, PFinished), 
				 (rule(RKey, Name, DKey, RHS, Matchable, noSubData, empty, RFinished) , Rules)) =
		setupProg(prog((RKey , RKeys), empty, s Speci, (Name * CNames),
					   PFinished and RFinished),
				  Rules) .
	
	
	*** filters the operator declarations for predicates out of the 
	*** modules predicate list
	op setupPredOps : OpDeclSet -> OpDeclSet .
	eq setupPredOps(((op Name : TyL -> Ty [ (Attribs1 metadata(IndParams) Attribs2) ].) Ops)) =
		if find(IndParams, "pred", 0) =/= notFound
		then (op Name : TyL -> Ty [ (Attribs1 metadata(IndParams) Attribs2) ].) 
			 setupPredOps(Ops) 
		else setupPredOps(Ops)
		fi .
	eq setupPredOps(Ops) = none [owise] .
	
	op setupMatchable : OpDeclSet -> FunNameSet .
	*** eq setupMatchable(none) = noName .
	eq setupMatchable(((op Name : TyL -> Ty [ (Attribs1 metadata(IndParams) Attribs2) ].) Ops)) =
		if find(IndParams, "nomatch", 0) =/= notFound
		then setupMatchable(Ops) 
		else Name * setupMatchable(Ops)
		fi .
	***eq setupMatchable(((op Name : TyL -> Ty [ (Attribs1 ctor Attribs2) ].) Ops)) =
	eq setupMatchable(Ops) = noName [owise] .
	***	setupMatchable(Ops) .
	
	
	op setupInduce : OpDeclSet -> FunNameSet .
	***eq setupInduce(none) = noName .
	eq setupInduce(((op Name : TyL -> Ty [ (Attribs1 metadata(IndParams) Attribs2) ].) Ops)) =
		if find(IndParams, "induce", 0) =/= notFound
		then Name * setupInduce(Ops) 
		else setupInduce(Ops)
		fi .
	eq setupInduce(Ops) = noName [owise] .
	
	*** yields the constructors Coarities
	op getCoas : OpDeclSet -> Coarities .
	eq getCoas(((op Name : TyL -> Ty [ (Attribs1 ctor Attribs2) ].) Ops)) =
		(Name :...-> Ty) ; getCoas(Ops) .
	eq getCoas(Ops) = none [owise] .
	
	
	op setupExpls : Module EquationSet FunNameSet FunNameSet IOSet Nat InitEKeySets 
			-> ExplsResult .
	eq setupExpls(Mod, none, IndNames, MatchNames, Expls, EC, AnnEKeys) = 
		< Expls , EC , AnnEKeys > .
	ceq setupExpls(Mod, (eq Name [ Input ] = Output [ Attribs ]. Eqs), IndNames, 
				   MatchNames, Expls, EC, AnnEKeys) =
		setupExpls(Mod, Eqs, IndNames, MatchNames, UpdExpls, UpdEC, UpdAnnEKeys)
		if < UpdExpls , UpdEC , UpdAnnEKeys > := 
			insertExpl(Mod, IndNames, MatchNames, Name, Input, Output, Expls, empty, EC, AnnEKeys) .
		
	op insertExpl : Module FunNameSet FunNameSet Qid TermList Term IOSet IOSet Nat 
					InitEKeySets -> ExplsResult .
	eq insertExpl(Mod, IndNames, MatchNames, Name, Input, O, empty, Expls, EC, AnnEKeys) = 
		if (IndNames * MatchNames) contains Name
		then < (ioEntry(EC, 'in [ Input ], < Name , O >) , Expls) , s EC , 
				if IndNames contains Name 
		  		then insertAnnEKey(EC, Name, AnnEKeys) 
		  		else AnnEKeys
		  		fi > 
		else < empty , EC , AnnEKeys > 
		fi .
	eq insertExpl(Mod, IndNames, MatchNames, Name, Input, O, 
				  (ioEntry(EKey, In, Outs) , Expls), Expls2, EC, AnnEKeys) =
		if (IndNames * MatchNames) contains Name
		then 
		(if renaming?(metaMatch(Mod, 'in [ Input ], In, nil, 0))
		then < (ioEntry(EKey, In, (< Name , (O metaMatch(Mod, 'in [ Input ], In, nil, 0)) > , Outs)) , 
				Expls , 
				Expls2) , 
			   EC ,
			   if IndNames contains Name 
		  	   then insertAnnEKey(EKey, Name, AnnEKeys) 
		  	   else AnnEKeys
		       fi >
		else insertExpl(Mod, IndNames, MatchNames, Name, Input, O, Expls, 
						(ioEntry(EKey, In, Outs) , Expls2), EC, AnnEKeys)
		fi) 
		else < (ioEntry(EKey, In, Outs) , Expls) , EC , AnnEKeys > 
		fi .
		
	op insertAnnEKey : Nat Qid InitEKeySets -> InitEKeySets .
	eq insertAnnEKey(EKey, Name, (< EKeys ; Name > AnnEKeys)) =
		< (EKey , EKeys) ; Name > AnnEKeys .
	eq insertAnnEKey(EKey, Name, AnnEKeys) =
		< EKey ; Name > AnnEKeys [owise] .
		
	
	op setupRuleDataSet : InitEKeySets RuleDataSet Nat IODataSet Nat IOSet 
		FunNameSet Coarities -> RuleDataResult .
	eq setupRuleDataSet(none, Rules, RC, IOSubsets, DC, Expls, Matchable, Coas) = 
		< Rules , RC , IOSubsets , DC > .
		
	***ceq setupRuleDataSet((< EKeys ; Name > AnnEKeys), 
	***					 Rules, RC,
	*** *					 (ioData(DKey, EKeys, InData, ODS, empty, noParts) , IOSubsets),
	***					 DC, Expls, Matchable, Coas) =
	***	setupRuleDataSet(AnnEKeys, 
	*** *					 (rule(RC, Name, DKey, RHS, Matchable, noSubData, Finished) , Rules),
	***					 s RC,
	*** *					 (UpdIOSubset , IOSubsets),
	***					 DC, Expls, Matchable, Coas) 
	***	if < RHS , Finished , UpdIOSubset > := 
	***		introduceOutData(Name, 
	***						 ioData(DKey, EKeys, InData, ODS, empty, noParts), 
	***						 Expls, Coas) .
					 
	ceq setupRuleDataSet((< EKeys ; Name > AnnEKeys), Rules, RC, IOSubsets, DC, 
						 Expls, Matchable, Coas) =
		setupRuleDataSet(AnnEKeys, 
						 (rule(RC, Name, DKey, RHS, Matchable, noSubData, empty, Finished) , Rules),
						 s RC, 
						 (IOSubset , UpdIOSubsets),
						 UpdDC, Expls, Matchable, Coas)
		if *** not(in(EKeys, IOSubsets)) /\
		   < DKey , (ioData(DKey, EKeys, InData, ODS, nil, empty, noParts, noParts) , UpdIOSubsets) , UpdDC > :=
		   	introduceIOData(DC, EKeys, Expls, Coas, IOSubsets) /\
		   < RHS , Finished , IOSubset > :=
			introduceOutData(Name, 
							 ioData(DKey, EKeys, InData, ODS, nil, empty, noParts, noParts),
							 Expls, Coas) .
							 
	
	
endfm


*** controls the overall induction process
fmod INDUCTION is
	inc HYPOTHESES .
	inc MAIN-PARAMETERS .
	inc PARTITIONING .
	inc SUBPROGRAMS .
	inc MATCHING .
	inc PREDICATES .

	vars Progs BestProgs PProgs PrProgs RemProgs RProgs SProgs MProgs Progs2 UnfinishedProgs : ProgramSet .
	vars Rules PRules SRules MRules PrRules : RuleDataSet .
	vars RC DC EC FC MRC MDC MEC MFC PRC PDC PEC PFC PrRC PrDC PrEC PrFC SRC SDC SEC SFC 
		 Speci BestSpeci RKey RemSteps : Nat .
	vars IOSubsets PIOSubsets SIOSubsets MIOSubsets PrIOSubsets : IODataSet .
	vars Expls PExpls SExpls MExpls PrExpls : IOSet .
	var PredOps : OpDeclSet .
	var Coas : Coarities .
	var Mode : PartMode .
	var Finished Count : Bool .
	var RKeys : KeySet .
	var Cs : CallPairSet .
	var IState : InductionState .
	var CNames : FunNameSet .
	var ModName : Qid .
	vars Depth PDepth MDepth SDepth PrDepth : IndexNamePairSet .
	

	op induce : InductionState OpDeclSet Coarities PartMode Qid Nat Bool -> InductionState .
	ceq induce(istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth), 
			   PredOps, Coas, Mode, ModName, RemSteps, Count) = 
		if RemSteps == 0
		then istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth)
		else induce(processRules(***getUnfinishedRules((prog(RKeys, Cs, Speci, CNames, false) , UnfinishedProgs)),
								 RKeys,  
								 istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth), 
								 PredOps, Coas, Mode, ModName), 
					PredOps, Coas, Mode, ModName,
					(if Count then sd(RemSteps, 1) else RemSteps fi), Count)
		fi
		if BestProgs := getBestProgs(Progs) /\
		   (prog(RKeys, Cs, Speci, CNames, false) , UnfinishedProgs) := 
			getUnfinishedProgs(BestProgs) /\
		   empty := getFinishedProgs(BestProgs) .
			
	ceq induce(istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth), 
			   PredOps, Coas, Mode, ModName, RemSteps, Count) = 
		istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth)
		if (prog(RKeys, Cs, Speci, CNames, true) , Progs2) := getBestProgs(Progs) .
			
	op getUnfinishedRules : ProgramSet -> KeySet .
	eq getUnfinishedRules(empty) = empty .
	eq getUnfinishedRules((prog(RKeys, Cs, Speci, CNames, false) , UnfinishedProgs)) =
		RKeys , getUnfinishedRules(UnfinishedProgs) .
			
	op getUnfinishedProgs : ProgramSet -> ProgramSet .
	eq getUnfinishedProgs((prog(RKeys, Cs, Speci, CNames, false) , Progs)) =
		prog(RKeys, Cs, Speci, CNames, false) , getUnfinishedProgs(Progs) .
	eq getUnfinishedProgs(Progs) = empty [owise] .
	
	op getFinishedProgs : ProgramSet -> ProgramSet .
	eq getFinishedProgs((prog(RKeys, Cs, Speci, CNames, true) , Progs)) =
		prog(RKeys, Cs, Speci, CNames, true) , getFinishedProgs(Progs) .
	eq getFinishedProgs(Progs) = empty [owise] .
		
		
	op getBestProgs : ProgramSet -> ProgramSet .
	eq getBestProgs(empty) = empty .
	eq getBestProgs((prog(RKeys, Cs, Speci, CNames, Finished) , 
					 Progs)) =
		$getBestProgs(Progs,
					  prog(RKeys, Cs, Speci, CNames, Finished),
					  Speci) .
						  
	op $getBestProgs : ProgramSet ProgramSet Nat -> ProgramSet .
	eq $getBestProgs(empty, BestProgs, BestSpeci) = BestProgs .
	eq $getBestProgs((prog(RKeys, Cs, Speci, CNames, Finished) , 
					  Progs),
					 BestProgs,
					 BestSpeci) =
		if Speci < BestSpeci
		then $getBestProgs(Progs,
						   prog(RKeys, Cs, Speci, CNames, Finished),
						   Speci)
		else (if Speci == BestSpeci
			  then $getBestProgs(Progs, 
				  				 (prog(RKeys, Cs, Speci, CNames, Finished) , 
				  				  BestProgs),
				  				 BestSpeci)
			  else $getBestProgs(Progs, BestProgs, BestSpeci)
			  fi)
		fi .
			
			
	op processRules : KeySet InductionState OpDeclSet Coarities PartMode Qid
		-> InductionState .
	
	eq processRules(empty, IState, PredOps, Coas, Mode, ModName) = IState .
	
	eq processRules((RKey , RKeys), 
					istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth),
					PredOps, Coas, Mode, ModName) =
		if finished(RKey, Rules) 
		then processRules(RKeys, 
						  istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth),
						  PredOps, Coas, Mode, ModName)
		else ***processRules(RKeys, 
						  processRule(RKey, 
						  			  istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth),
						  			  PredOps, Coas, Mode, ModName) ***,
						  ***PredOps, Coas, Mode, ModName)
		fi .
		
	sort ProgSetPair .
	op <_,_> : ProgramSet ProgramSet -> ProgSetPair [ctor] .
		
	op processRule : Nat InductionState OpDeclSet Coarities PartMode Qid -> InductionState .
	
	ceq processRule(RKey, istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth), 
				    PredOps, Coas, Mode, ModName) =
		***subprograms(RKey, istate(RProgs, PRules, PRC, PIOSubsets, PDC, PExpls, PEC, PFC),
		   ***				Coas)
		***istate((PProgs , RemProgs), PRules, PRC, PIOSubsets, PDC, PExpls, PEC, PFC, PDepth)
		***istate((MProgs , PrProgs, PProgs , RemProgs), MRules, MRC, MIOSubsets, MDC, MExpls, MEC, MFC, MDepth)
		istate((SProgs , MProgs , PProgs , RemProgs), SRules, SRC, SIOSubsets, SDC, SExpls, SEC, SFC, SDepth)
		***istate((PrProgs , PProgs, RemProgs), PrRules, PrRC, PrIOSubsets, PrDC, PrExpls, PrEC, PrFC, PrDepth)
		if < RProgs , RemProgs > := splitProgs(RKey, Progs, < empty , empty >) /\
		   istate(PProgs, PRules, PRC, PIOSubsets, PDC, PExpls, PEC, PFC, PDepth) :=
			partitioning(RKey, istate(RProgs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth), 
						 Coas, Mode) /\
		   ***istate(PrProgs, PrRules, PrRC, PrIOSubsets, PrDC, PrExpls, PrEC, PrFC, PrDepth) :=
		   	***predicates(RKey, istate(RProgs, PRules, PRC, PIOSubsets, PDC, PExpls, PEC, PFC, PDepth), 
				***	   PredOps, Coas, ModName, false) /\
		   istate(MProgs, MRules, MRC, MIOSubsets, MDC, MExpls, MEC, MFC, MDepth) :=
		   	matching(RKey, istate(RProgs, PRules, PRC, PIOSubsets, PDC, PExpls, PEC, PFC, PDepth), 
				 Coas, ModName) /\
		   istate(SProgs, SRules, SRC, SIOSubsets, SDC, SExpls, SEC, SFC, SDepth) :=
		    subprograms(RKey, istate(RProgs, MRules, MRC, MIOSubsets, MDC, MExpls, MEC, MFC, MDepth),
		   				Coas) .
		
	op splitProgs : Nat ProgramSet ProgSetPair -> ProgSetPair .
	eq splitProgs(RKey, 
				  (prog((RKey , RKeys), Cs, Speci, CNames, Finished) , 
				   Progs),
				  < RProgs , RemProgs >) =
		splitProgs(RKey, Progs, 
				   < (prog((RKey , RKeys), Cs, Speci, CNames, Finished) , 
				      RProgs) ,
				     RemProgs >) .
	eq splitProgs(RKey, Progs, < RProgs , RemProgs >) =
		< RProgs , (Progs , RemProgs) > [owise] .
		
endfm


*** takes the final induction state and computes the hypotheses/modules
fmod FINISH is
	inc META-LEVEL .
	inc INDUCTION .
	inc HYPOTHESES .
	
	sorts Hypo HypoList .
	subsort Hypo < HypoList .
	op hypo : Bool Nat EquationSet -> Hypo [ctor] .
	op noHypo : -> HypoList [ctor] .
	op _nextHypo_ : HypoList HypoList -> HypoList [ctor assoc id: noHypo format (d nn nn d)] .
	
	
	var Prog : Program .
	var Progs : ProgramSet .
	var Rules : RuleDataSet .
	vars RC DC EC FC RKey DKey Index Speci : Nat .
	var IOSubsets : IODataSet .
	var Expls : IOSet .
	vars RKeys EKeys : KeySet .
	var Cs : CallPairSet .
	var Finished : Bool .
	var Name : Qid .
	vars RHS T B : Term .
	var Matchable CNames : FunNameSet .
	vars Inputs Preds : TermList .
	var Cond : EqCondition .
	var SD : SubstitutionData .
	var ODS : OutDataSet .
	vars Parts PParts : Partitions .
	var Sub : SubData .
	var Matches : MatchDataSet .
	var Depth : IndexNamePairSet .
	
	op finishAll : InductionState -> HypoList .
	op finishBest : InductionState -> HypoList .
	op finish : InductionState -> HypoList .
	op $finish : ProgramSet RuleDataSet IODataSet -> HypoList .
	
	eq finishAll(istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth)) =
		$finish(Progs, Rules, IOSubsets) .
		
	eq finish(istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth)) =
		$finish(getFinished(Progs), Rules, IOSubsets) .

	eq finishBest(istate(Progs, Rules, RC, IOSubsets, DC, Expls, EC, FC, Depth)) =
		$finish(getBestProgs(getFinished(Progs)), Rules, IOSubsets) .
		
	op getFinished : ProgramSet -> ProgramSet .
	eq getFinished((prog(RKeys, Cs, Speci, CNames, true) , Progs)) =
		prog(RKeys, Cs, Speci, CNames, true) , getFinished(Progs) .
	eq getFinished(Progs) = empty [owise] .
		
	eq $finish(empty, Rules, IOSubsets) = noHypo .
	eq $finish((Prog , Progs), Rules, IOSubsets) =
		createHypo(Prog, Rules, IOSubsets) nextHypo
		$finish(Progs, Rules, IOSubsets) .
		
	op createHypo : Program RuleDataSet IODataSet -> Hypo .
	eq createHypo(prog(RKeys, Cs, Speci, CNames, Finished),
				  Rules, IOSubsets) =
		hypo(Finished, Speci, createEqs(RKeys, Rules, IOSubsets)) .
		
	op createEqs : KeySet RuleDataSet IODataSet -> EquationSet .
	eq createEqs(empty, Rules, IOSubsets) = none .
	eq createEqs((RKey , RKeys), 
				 (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, Finished) , 
				  Rules),
				 (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , Index >, ODS, nil, Preds, Parts, PParts) , IOSubsets)) =
		(eq Name [ Inputs ] = RHS [ none ].) 
		createEqs(RKeys, Rules, (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , Index >, ODS, nil, Preds, Parts, PParts) , IOSubsets)) .
	eq createEqs((RKey , RKeys), 
				 (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, Finished) , 
				  Rules),
				 (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , Index >, ODS, ((T = B) /\ Cond), Preds, Parts, PParts) , IOSubsets)) =
		(ceq Name [ Inputs ] = RHS if ((T = B) /\ Cond) [ none ].) 
		createEqs(RKeys, Rules, (ioData(DKey, EKeys, < 'in [ Inputs ] , SD , Index >, ODS, ((T = B) /\ Cond), Preds, Parts, PParts) , IOSubsets)) .
		
endfm

fmod IGOR is
	inc SETUP .
	inc INDUCTION .
	inc FINISH .
	inc META-LEVEL .
	
	op setup : Qid Nat Bool -> HypoList .
	***op setup : Qid Nat Bool -> InductionState .
	***op setup : Qid Nat Bool -> ProgramSet .
	
	var ModName Name : Qid .
	var Prog : Program .
	vars Rules IRules : RuleDataSet .
	vars RC DC EC FC IRC IDC IEC IFC DKey RKey Steps : Nat .
	vars IOSubsets IIOSubsets : IODataSet .
	var PredOps : OpDeclSet .
	var Coas : Coarities .
	var IProgs : ProgramSet .

	vars Expls IExpls : IOSet .
	*** var EC : Nat .
	var AnnEKeys : InitEKeySets .
	vars RHS Pattern : Term .
	var InAssigns : SubstitutionData .
	var VarIndex : Nat .
	var EKeys : KeySet .
	var ID : SubstitutionData .
	var ODS : OutDataSet .
	var SD : SubstitutionData .
	var Preds : TermList .
	vars V1 V2 : Variable .
	vars ITs ITs1 ITs2 : IndexedTerms .
	vars Poss Poss1 Poss2 : Positions .
	var Sub : SubData .
	var Finished Count : Bool .
	var Matchable : FunNameSet .
	var Matches : MatchDataSet .
	vars Depth IDepth : IndexNamePairSet .

	*** idata : Program RuleDataSet Nat IODataSet Nat IOSet Nat OpDeclSet Coarities
	*** processRule : Nat InductionState OpDeclSet Coarities PartMode
	
	ceq setup(ModName, Steps, Count) =
		finishBest(
		istate(IProgs, IRules, IRC, IIOSubsets, IDC, IExpls, IEC, IFC, IDepth)
		***
		***getBestProgs(IProgs) 
		)
		*** processRule(1, istate(Prog, Rules, RC, IOSubsets, DC, Expls, EC), PredOps, Coas, medium)
		*** compPartitions(EKeys, (< V1 ; ITs1 ; Poss1 > , < V2 ; ITs2 ; Poss2 >), IOSubsets, DC, Expls, Coas)
		if idata(Prog, Rules, RC, IOSubsets, DC, Expls, EC, FC, PredOps, Coas) :=
			setupInductionData(upModule(ModName, true), 
						   upOpDecls(ModName, true), 
						   upEqs(ModName, true)) /\
		*** istate(IProgs, IRules, IRC, IIOSubsets, IDC, IExpls, IEC, IFC, IDepth) :=
		  *** 	istate(Prog, Rules, RC, IOSubsets, DC, Expls, EC, FC, empty) .
		   istate(IProgs, IRules, IRC, IIOSubsets, IDC, IExpls, IEC, IFC, IDepth) :=
		   	induce(istate(Prog, Rules, RC, IOSubsets, DC, Expls, EC, FC, empty), 
		   		   PredOps, Coas, medium, ModName, Steps, Count) .
						   
	***op test : Qid -> PartitionsResult .
	***ceq test(ModName) =
		***introduceIOData(2, 1, Expls, Coas, ioData(DKey, EKeys, < Pattern , (< 'X1:List ; ITs ; Poss > , SD) , VarIndex >, ODS, Preds, noParts))
		***$compPartition(EKeys, < 'X1:List ; ITs ; Poss >)
		***compPartition(EKeys, < 'X1:List ; ITs ; Poss >, 
			***		   ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, Preds, noParts),
				***	   DC, Expls, Coas)
		***if idata(Prog, rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, Finished), RC, 
			***	 ioData(DKey, EKeys, < Pattern , (< 'X1:List ; ITs ; Poss > , SD) , VarIndex >, ODS, Preds, noParts), DC,
				*** Expls, EC, FC, PredOps, Coas) :=
			***setupInductionData(upModule(ModName, false), 
				***		   upOpDecls(ModName, false), 
					***	   upEqs(ModName, false)) .
	
endfm
