
fmod MATCHING is
	inc HYPOTHESES .
	inc SHARED-SUB .
	
	sort MatchesIntroResult .
	op <_,_,_,_,_,_,_> : MatchDataSet RuleDataSet Nat IODataSet Nat IOSet Nat 
		-> MatchesIntroResult .
	
	
	vars RKey DKey EKey EKey1 EKey2 MKey RC DC EC UpdRC UpdDC FC UpdFC ArgDKey
		 Index VarIndex UpdIndex Speci ResultRC ResultDC ResultFC Num : Nat .
	var Progs : ProgramSet .
	vars Name Matched ModName N1 N2 N3 N4 Called Root : Qid .
	vars RHS Pattern I O MOut MIn Out In SMIn NewOut T : Term .
	vars Matchable CNames Names : FunNameSet .
	var Sub : SubData .
	var Match : MatchData .
	vars Matches MoreMatches : MatchDataSet .
	vars Rules UpdRules ResultRules : RuleDataSet .
	vars IOSubsets UpdIOSubsets ResultIOSubsets : IODataSet .
	vars Expls UpdExpls ResultExpls : IOSet .
	var Coas : Coarities .
	vars EKeys RKeys FragRKeys : KeySet .
	var SD : SubstitutionData .
	var ODS : OutDataSet .
	vars Preds Subterms RSubterms TL RTL NewOuts MIns : TermList .
	vars Parts PParts : Partitions .
	var Cs Cs1 Cs2 : CallPairSet .
	vars Finished FragFinished Mode : Bool .
	vars Calls Calls1 Calls2 Calls3 MutualCalls : Callclass .
	vars InVecs Outs MInVecs MOuts SMInVecs : IndexedTerms .
	vars MKeys PMKeys PMKeys1 PMKeys2 : MatchKeys .
	var NOs : NamedOutputs .
	var Result : MatchesIntroResult .
	vars MState MState1 MState2 : MatchState .
	var Sigma : Substitution? .
	vars V V1 V2 V3 VR : Variable .
	var C : Constant .
	vars Vs1 Vs2 : Variables .
	var ID : AUResult .
	var ArgNames : FunNameList .
	var Prog : Program .
	var Sor : Sort .
	var SubstRes : AppSubstResult .
	vars IOSubset UpdIOSubset : IOData .
	var Mod : Module .
	var CP : CallPair .
	var D : Nat .
	var Depth : IndexNamePairSet .
	var Cond : EqCondition .
	
	
	
	
	op matching : Nat InductionState Coarities Qid -> InductionState .	
	
	*** matches exist already, just integrate them
	eq matching(RKey, 
				istate(Progs, 
					   (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
					   		 (Match , Matches), false) , Rules), RC, 
					   IOSubsets, DC, Expls, EC, FC, Depth), 
				Coas, ModName) =
		istate(integrateMatches(RKey, (Match , Matches), Rules, Progs), 
			   (rule(RKey, Name, DKey, RHS, Matchable, Sub, (Match , Matches), 
					 false) , Rules), RC, 
			   IOSubsets, DC, Expls, EC, FC, Depth) . 
			 
	eq matching(RKey, 
				istate(Progs, 
					   (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
					   		 failed, false) , Rules), RC, 
					   IOSubsets, DC, Expls, EC, FC, Depth), 
				Coas, ModName) =
		 istate(empty, 
				(rule(RKey, Name, DKey, RHS, Matchable, Sub, failed, false) , Rules), 
				RC, IOSubsets, DC, Expls, EC, FC, Depth) .
			  
	ceq matching(RKey,
				 istate(Progs, 
					    (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
					   		  empty, false) , Rules), RC, 
					    (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
					   		    Cond, Preds, Parts, PParts) , IOSubsets), DC, 
					   	 Expls, EC, FC, (< D : Name > , Depth)), 
				 Coas, ModName) =
		istate(if Matches == empty then empty else
					integrateMatches(RKey, Matches, UpdRules, Progs) fi, 
			   (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
			   		 if Matches == empty then failed else Matches fi, 
					 false) , UpdRules), UpdRC, 
			   UpdIOSubsets, UpdDC, UpdExpls, EC, UpdFC, 
			   (createDepth((s D), getSubnames(Matches)) ,  < D : Name > , Depth))
		if D < 3 /\
		   < Matches , UpdRules , UpdRC , UpdIOSubsets , UpdDC , UpdExpls , UpdFC > :=
			introduceMatches(Matchable, Name, EKeys, getInputs(EKeys, Expls), 
							 getOutputs(EKeys, Name, Expls), 
							 DKey, Pattern, Matchable, 
							 Rules, RC, 
							 (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
							 		 Cond, Preds, Parts, PParts) , IOSubsets),
							 DC, Expls, FC, Coas, ModName) .
							 
	ceq matching(RKey,
				 istate(Progs, 
					    (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
					   		  empty, false) , Rules), RC, 
					    (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
					   		    Cond, Preds, Parts, PParts) , IOSubsets), DC, 
					   	 Expls, EC, FC, (< D : Name > , Depth)), 
				 Coas, ModName) =
		istate(empty, 
				(rule(RKey, Name, DKey, RHS, Matchable, Sub, empty, false) , Rules), 
				RC, (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
					   		    Cond, Preds, Parts, PParts) , IOSubsets), DC, Expls, EC, FC, (< D : Name > , Depth))
		if D >= 3 . 		 
							 
	ceq matching(RKey,
				 istate(Progs, 
					    (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
					   		  empty, false) , Rules), RC, 
					    (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
					   		    Cond, Preds, Parts, PParts) , IOSubsets), DC, 
					   	 Expls, EC, FC, Depth), 
				 Coas, ModName) =
		istate(if Matches == empty then empty else
					integrateMatches(RKey, Matches, UpdRules, Progs) fi, 
			   (rule(RKey, Name, DKey, RHS, Matchable, Sub, 
			   		 if Matches == empty then failed else Matches fi, 
					 false) , UpdRules), UpdRC, 
			   UpdIOSubsets, UpdDC, UpdExpls, EC, UpdFC, 
			   (createDepth(1, getSubnames(Matches)) , Depth))
		if not((Depth contains Name)) /\
		   < Matches , UpdRules , UpdRC , UpdIOSubsets , UpdDC , UpdExpls , UpdFC > :=
			introduceMatches(Matchable, Name, EKeys, getInputs(EKeys, Expls), 
							 getOutputs(EKeys, Name, Expls), 
							 DKey, Pattern, Matchable, 
							 Rules, RC, 
							 (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, ODS, 
							 		 Cond, Preds, Parts, PParts) , IOSubsets),
							 DC, Expls, FC, Coas, ModName) .
							 						
		
	
	op getSubnames : MatchDataSet -> FunNameSet .
	eq getSubnames(empty) = noName .
	eq getSubnames((< RKeys , CP , Names , Finished > , Matches)) =
		Names * getSubnames(Matches) .
		
	op integrateMatches : Nat MatchDataSet RuleDataSet ProgramSet -> ProgramSet .
	eq integrateMatches(RKey, Matches, Rules,
			(prog((RKey , RKeys), Cs, Speci, CNames, Finished) , Progs)) =
		integrateMatches(RKey, Matches, Rules, 
				 ($integrateMatches(RKey, Matches, getRules(RKeys, Rules), 
				 					prog((RKey , RKeys), Cs, Speci, CNames, Finished)) ,
				  Progs)) .
		***if < UpdCallRed , UpdCallEq , UpdCallInc > := 
		***	updateCallRelations(Name, Names, CallRed, CallEq, CallInc, empty, empty, empty) .
	eq integrateMatches(RKey, Matches, Rules, Progs) = Progs [owise] .
	
	op $integrateMatches : Nat MatchDataSet RuleDataSet Program -> ProgramSet .
	eq $integrateMatches(RKey, empty, Rules, Prog) = empty .
	eq $integrateMatches(RKey,  
						 (< FragRKeys , (Name Calls Matched), Names , FragFinished > , Matches), 
						 Rules, 
						 prog((RKey , RKeys), Cs, Speci, CNames, Finished)) =
		if (Calls > getClass(Name, Matched, Cs)) or
		   not(testMutual(Name, Calls, Matched, 
		   				  getClass(Matched, Name, Cs)))
		then $integrateMatches(RKey, Matches, Rules, 
							   prog((RKey , RKeys), Cs, Speci, CNames, Finished))
		else (prog((FragRKeys , RKeys), 
			 	   if Name == Matched
			 	   then ((Name Calls Matched) , updCalls(Name, Names, Cs, empty))
			 	   else (trans(getCalling(Name, Cs), 
				  			   (Name Calls Matched), 
							   getCalled(Matched, Cs)) ,
				   		 updCalls(Name, Names, Cs, empty))
				   fi,
			 				 			 *** *(Speci + (numberOf Names in CNames)), 
			 	  ***if (CNames contains Matched)
			 	  ***then Speci
			 	  ***else countRules((FragRKeys , RKeys), Matched, Rules) + Speci
			 	  ***fi,
			 	  Speci,
			 	  if (CNames contains Matched)
			 	  then CNames
			 	  else (CNames * Matched)
			 	  fi,
			 	  finished(RKeys, Rules) and FragFinished) , 
			 $integrateMatches(RKey, Matches, Rules, 
			 				   prog((RKey , RKeys), Cs, Speci, CNames, Finished)))
		fi .
		
		
	op countRules : KeySet Qid RuleDataSet -> Nat .
	eq countRules((RKey , RKeys), Name, 
				  (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, Finished) ,
				   Rules)) =
		s countRules(RKeys, Name, Rules) .
	eq countRules(RKeys, Name, Rules) = 0 [owise] .
		
	
	op getCalling : Qid CallPairSet -> CallPairSet .
	eq getCalling(N2, ((N1 Calls N2) , Cs)) =
		if N1 =/= N2 
		then (N1 Calls N2) , getCalling(N2, Cs) 
		else getCalling(N2, Cs)
		fi .
	eq getCalling(N2, Cs) = empty [owise] .
	
	op getCalled : Qid CallPairSet -> CallPairSet .
	eq getCalled(N1, ((N1 Calls N2) , Cs)) =
		if N1 =/= N2
		then (N1 Calls N2) , getCalled(N1, Cs) 
		else getCalled(N1, Cs)
		fi .
	eq getCalled(N1, Cs) = empty [owise] .
	
	
	op trans : CallPairSet CallPair CallPairSet -> CallPairSet .
	eq trans(((N1 Calls1 N2) , Cs1), (N2 Calls2 N3), Cs2) =
		$trans((N1 Calls1 N2), (N2 Calls2 N3), Cs2) ,
		trans(Cs1, (N2 Calls2 N3), Cs2) .
	eq trans(empty, (N2 Calls2 N3), empty) = N2 Calls2 N3 .
	eq trans(empty, (N2 Calls2 N3), ((N3 Calls3 N4), Cs)) =
		if (Calls2 == callsInc) or (Calls3 == callsInc)
		then (N2 callsInc N4) , trans(empty, (N2 Calls2 N3), Cs) 
		else (if (Calls2 == callsRed) or (Calls3 == callsRed)
			  then (N2 callsRed N4) , trans(empty, (N2 Calls2 N3), Cs) 
			  else (N2 callsEq N4) , trans(empty, (N2 Calls2 N3), Cs)
			  fi)
		fi .
	
	op $trans : CallPair CallPair CallPairSet -> CallPairSet .
	eq $trans((N1 Calls1 N2), (N2 Calls2 N3), ((N3 Calls3 N4) , Cs)) =
		if (Calls1 == callsInc) or (Calls2 == callsInc) or (Calls3 == callsInc)
		then (N1 callsInc N4) , $trans((N1 Calls1 N2), (N2 Calls2 N3), Cs) 
		else (if (Calls1 == callsRed) or (Calls2 == callsRed) or (Calls3 == callsRed)
			  then (N1 callsRed N4) , $trans((N1 Calls1 N2), (N2 Calls2 N3), Cs) 
			  else (N1 callsEq N4) , $trans((N1 Calls1 N2), (N2 Calls2 N3), Cs)
			  fi)
		fi .
	eq $trans((N1 Calls1 N2), (N2 Calls2 N3), empty) =
		if (Calls1 == callsInc) or (Calls2 == callsInc)
		then (N1 callsInc N3)
		else (if (Calls1 == callsRed) or (Calls2 == callsRed)
			  then (N1 callsRed N3)
			  else (N1 callsEq N3)
			  fi)
		fi .
	
	*** computes the transitive closure of the calls relations.
	***op transClosure : CallPairSet -> CallPairSet .
	***eq transClosure(((N1 Calls1 N2) , (N2 Calls2 N3) , Cs)) =
	***	if not((N1 , N3 in ((N1 Calls1 N2) , (N2 Calls2 N3) , Cs)))
		   *** i.e., the pair N1,N3 is missing
	***	then (if (Calls1 == callsInc) or (Calls2 == callsInc)
	***		  then *** closure over any inc is inc
	***		  	   transClosure(((N1 Calls1 N2) , (N2 Calls2 N3) , (N1 callsInc N3) , Cs))
	***		  else (if Calls1 == callsEq 
	***		  		then *** closure over eq depends on rest
	***		  			 transClosure(((N1 callsEq N2) , (N2 Calls2 N3) , (N1 Calls2 N3) , Cs))
	***		  		else *** i.e., Calls1 == callsRed and Calls2 =/= callsInc
	***		  			 transClosure(((N1 callsRed N2) , (N2 Calls2 N3) , (N1 callsRed N3) , Cs))
	***		  		fi)
	***		  fi)
	***	else *** no missing pair
	*** *		 ((N1 Calls1 N2) , (N2 Calls2 N3) , Cs)
	***	fi .
	*** eq transClosure(Cs) = Cs [owise] .
	
	
	
	*** first qid is name of calling function, second qid name of called function,
	*** first callclass is class of the call, second callclass is class of the
	*** mutual call, i.e. of second qid calls first qid if it exists
	op testMutual : Qid Callclass Qid Callclass -> Bool .
	*** if a mutual call doesn't exist, every call is okay
	eq testMutual(Name, Calls, Called, none) = true .
	*** if the call is eq then a red mutual call is okay
	eq testMutual(Name, callsEq, Called, callsRed) = true .
	*** if the call is red then an eq or red mutual call is okay
	eq testMutual(Name, callsRed, Called, callsEq) = true .
	eq testMutual(Name, callsRed, Called, callsRed) = true .
	*** any other combination is not allowed
	eq testMutual(Name, Calls, Called, MutualCalls) = false [owise] .
	
	
		
		
	*** ALLE MGL. MATCHES HINZUFUEGEN ******************************************
	*** introduceMatches und Hilfsfunktionen
	****************************************************************************
	op introduceMatches : FunNameSet Qid KeySet IndexedTerms IndexedTerms 
						  Nat Term FunNameSet RuleDataSet Nat IODataSet Nat IOSet Nat 
						  Coarities Qid -> MatchesIntroResult .
	eq introduceMatches(noName, Name, EKeys, InVecs, Outs, DKey, Pattern, 
						Matchable, Rules, RC, IOSubsets, DC, 
						Expls, FC, Coas, ModName) =
		< empty , Rules, RC, IOSubsets, DC, Expls, FC > .
	ceq introduceMatches((Matched * Names), Name, EKeys, InVecs, Outs, DKey, 
						 Pattern, Matchable, Rules, RC, 
	 					 IOSubsets, DC, Expls, FC, Coas, ModName) =
		< (Matches , MoreMatches) , ResultRules , ResultRC , 
		  ResultIOSubsets , ResultDC , ResultExpls , ResultFC >
		if MKeys := getMatchKeys(Matched, Expls) /\
		   MInVecs := getInputs(Matched, Expls) /\
		   MOuts := getOutputs(Matched, Expls) /\
		   < Matches , UpdRules , UpdRC , UpdIOSubsets , UpdDC , UpdExpls , UpdFC > :=
			callMatching(Matched, Name, 
					 initMatchState(EKeys, MKeys, Outs, MOuts, 
					 				allCallclassesAllowed?(Matched, Name), 
					 				InVecs, MInVecs, Coas,
					 				upModule(ModName, true)),
					 MInVecs, MOuts,
					 EKeys, InVecs, Outs,
					 DKey, Pattern, Matchable, 
					 < empty , Rules, RC, IOSubsets, DC, Expls, FC >, Coas, ModName) /\
		   < MoreMatches , ResultRules , ResultRC , ResultIOSubsets , ResultDC , ResultExpls , ResultFC > :=
		   	introduceMatches(Names, Name, EKeys, InVecs, Outs, DKey, Pattern, Matchable, 
		   					 UpdRules, UpdRC, 
		   					 UpdIOSubsets, UpdDC, UpdExpls, UpdFC, Coas, ModName) .
		   					 
	
	op getMatchKeys : Qid IOSet -> MatchKeys .
	eq getMatchKeys(Matched, (ioEntry(MKey, I, (< Matched , O > , NOs)) , Expls)) =
		MKey nextKey getMatchKeys(Matched, Expls) .
	eq getMatchKeys(Matched, Expls) = noKeys [owise] .
	
	op initMatchState : KeySet MatchKeys IndexedTerms IndexedTerms Bool 
						IndexedTerms IndexedTerms Coarities Module -> MatchState .
	eq initMatchState(empty, MKeys, none, MOuts, Mode, none, MInVecs, Coas, Mod) = empty .
	ceq initMatchState((EKey , EKeys), MKeys, (< EKey , Out > , Outs), MOuts, Mode, 
					   (< EKey , In > , InVecs), MInVecs, Coas, Mod) =
		< EKey : PMKeys : PMKeys  > , 
		initMatchState(EKeys, MKeys, Outs, MOuts, Mode, InVecs, MInVecs, Coas, Mod) 
		if PMKeys := getPossibMKeys(Out, MOuts, Mode, In, MInVecs, MKeys, Coas, Mod) .
		
	op getPossibMKeys : Term IndexedTerms Bool Term IndexedTerms MatchKeys 
						Coarities Module -> MatchKeys .
	eq getPossibMKeys(Out, none, Mode, In, none, noKeys, Coas, Mod) = noKeys .
	eq getPossibMKeys(Out, (< MKey , MOut > , MOuts), Mode, 
					  In, (< MKey , MIn > , MInVecs), (MKey nextKey MKeys), Coas, Mod) =
		if getType(MOut, Coas) == getType(Out, Coas) 
		then (if (metaMatch(Mod, MOut, Out, nil, 0) =/= noMatch) and
		   		 (Mode or inSmallerSize(MIn, In)) *** * (size(MIn) < size(In)))
			  then MKey nextKey getPossibMKeys(Out, MOuts, Mode, In, MInVecs, MKeys, Coas, Mod)
			  else getPossibMKeys(Out, MOuts, Mode, In, MInVecs, MKeys, Coas, Mod)
			  fi)
		else getPossibMKeys(Out, MOuts, Mode, In, MInVecs, MKeys, Coas, Mod)
		fi .
	
	sort MatchKeys .	*** a list of keys of i/o-expls which are matched
	subsort Nat < MatchKeys .
	op noKeys : -> MatchKeys .
	op _nextKey_ : MatchKeys MatchKeys -> MatchKeys [ctor assoc id: noKeys] .
	
	sort MatchState .	*** a list of MatchStateItems with one
						*** Item for each io-key of current function
						*** i.e., one MatchState denotes one match
	sort MatchStateItem .		*** an i/o-key of current rule together with 
								*** remaining keys to be matched
	subsort MatchStateItem < MatchState .
	op <_:_:_> : Nat MatchKeys MatchKeys -> MatchStateItem [ctor] .
	op empty : -> MatchState [ctor] .
	op _,_ : MatchState MatchState -> MatchState [ctor assoc id: empty] .
	
	
	
	
	*** ALLE MATCHES BZGL. EINES MATCHABLES HINZUFUEGEN ************************
	*** matching und Hilfsfunktionen
	****************************************************************************
	op callMatching : Qid Qid MatchState IndexedTerms IndexedTerms 
				  	  KeySet IndexedTerms IndexedTerms Nat Term FunNameSet 
				  	  MatchesIntroResult Coarities Qid
				  		-> MatchesIntroResult .
	eq callMatching(Matched, Name, (MState1 , < EKey : MKeys : noKeys > , MState2),
					MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, Result, 
					Coas, ModName) = Result .
	eq callMatching(Matched, Name, MState,
					MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, Result, 
					Coas, ModName) = 
		matching(Matched, Name, MState,
				 MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, Result, 
				 Coas, ModName) [owise] .
	
	
	op matching : Qid Qid MatchState IndexedTerms IndexedTerms 
				  KeySet IndexedTerms IndexedTerms Nat Term FunNameSet MatchesIntroResult 
				  Coarities Qid
				  	-> MatchesIntroResult .
	eq matching(Matched, Name, (MState , < EKey : noKeys : PMKeys >), 
				MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, Result, 
				Coas, ModName) = Result .
	eq matching(Matched, Name,
				(MState1 , < EKey1 : noKeys : PMKeys1 > , 
				 < EKey2 : (MKey nextKey MKeys) : PMKeys2 > , MState2),
				MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, 
				Result, Coas, ModName) =
		matching(Matched, Name, 
				 (MState1 , < EKey1 : PMKeys1 : PMKeys1 > , 
				  < EKey2 : MKeys : PMKeys2 > , MState2),
				 MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, 
				 Result, Coas, ModName) .
	eq matching(Matched, Name,  
				(< EKey : (MKey nextKey MKeys) : PMKeys > , MState), MInVecs, MOuts, 
				EKeys, InVecs, Outs, DKey, Pattern, Matchable, Result, Coas, ModName) =
		matching(Matched, Name, (< EKey : MKeys : PMKeys > , MState),
				 MInVecs, MOuts, EKeys, InVecs, Outs, DKey, Pattern, Matchable, 
				 introduceMatch(Matched, Name, DKey, Pattern, Matchable, EKeys,
					  			compSubstMInVecs((< EKey : (MKey nextKey MKeys) : PMKeys > , MState), 
					  							 MOuts, Outs, MInVecs, InVecs, 
					  							 allCallclassesAllowed?(Matched, Name),
					  							 < callsRed , none >, ModName),
								Result, Coas), 
				 Coas, ModName) [owise] .
		
	op allCallclassesAllowed? : Qid Qid -> Bool .
	eq allCallclassesAllowed?(Name, Name) = false .
	eq allCallclassesAllowed?(Matched, Name) =  
		substr(string(Matched), 0, 3) =/= "Sub" [owise] .
		
	sort AppSubstResult .
	op <_,_> : Callclass IndexedTerms -> AppSubstResult [ctor] .
		
	op compSubstMInVecs : MatchState IndexedTerms IndexedTerms 
						  IndexedTerms IndexedTerms Bool AppSubstResult Qid 
						  	-> AppSubstResult .
	eq compSubstMInVecs(empty, MOuts, Outs, MInVecs, InVecs, 
						Mode, SubstRes, ModName) = SubstRes .
	ceq compSubstMInVecs((< EKey : (MKey nextKey MKeys) : PMKeys > , MState), 
						 (< MKey , MOut > , MOuts), (< EKey , Out > , Outs),
						 (< MKey , MIn > , MInVecs), (< EKey , In > , InVecs), 
						 Mode, < Calls , SMInVecs >, ModName) =
		if (Sigma =/= noMatch) and (Calls =/= none)
		then compSubstMInVecs(MState, (< MKey , MOut > , MOuts), Outs, 
							  (< MKey , MIn > , MInVecs), InVecs, Mode, 
							  appAndInsSubst(Mode, EKey, 
							  				 replace(MIn, varDiff(var(MIn), var(MOut)), 
							  				 		 (var(In) # var(Out))), 
											 In, Sigma, < Calls , SMInVecs >),
							  ModName)
		else < none , none >
		fi
		if Sigma := metaMatch(upModule(ModName, true), MOut, Out, nil, 0) .
		
	op varDiff : Variables Variables -> Variables .
	eq varDiff((V # Vs1), (V # Vs2)) = varDiff(Vs1, Vs2) .
	eq varDiff(Vs1, Vs2) = Vs1 [owise] .
	
	sort TLIndexPair .
	op <_,_> : TermList Nat -> TLIndexPair [ctor] .
	
	*** replaces variables in the TermList that are in the first given
	*** variable set such that the new variables are not in the second
	*** variable set; every occurence of a replaced variable is 
	*** replaced by a unique variable, i.e., the same variable will be
	*** replaced by more than one new variables if it occurs more than once
	*** in the termlist
	op replace : TermList Variables Variables -> TermList .
	ceq replace(TL, Vs1, Vs2) = RTL
		if < RTL , Index > := $replace(TL, Vs1, Vs2, 0) .
		
	op $replace : TermList Variables Variables Nat -> TLIndexPair .
	eq $replace(empty, Vs1, Vs2, Index) = < empty , Index > .
	eq $replace(TL, noVars, Vs2, Index) = < TL , Index > .
	eq $replace((C , TL), (V # Vs1), Vs2, Index) = 
		integrate(C, $replace(TL, (V # Vs1), Vs2, Index)) .
	eq $replace((V1 , TL), (V2 # Vs1), noVars, Index) =
		if (V1 in (V2 # Vs1))
		then integrate(createMetaVariable(Index, getType(V1)), 
			 $replace(TL, (V2 # Vs1), noVars, s Index))
		else integrate(V1, $replace(TL, (V2 # Vs1), noVars, Index))
		fi .
	ceq $replace((V1 , TL), (V2 # Vs1), (V3 # Vs2), Index) =
		if (V1 in (V2 # Vs1))
		then (if (VR in (V3 # Vs2))
			  then $replace((V1 , TL), (V2 # Vs1), (V3 # Vs2), s Index)
			  else integrate(VR, $replace(TL, (V2 # Vs1), (V3 # Vs2), s Index))
			  fi)
		else integrate(V1, $replace(TL, (V2 # Vs1), (V3 # Vs2), Index))
		fi
		if VR := createMetaVariable(Index, getType(V1)) .
	ceq $replace((Root [ Subterms ] , TL), Vs1, Vs2, Index) =
		integrate(Root [ RSubterms ], $replace(TL, Vs1, Vs2, UpdIndex))
		if < RSubterms , UpdIndex > := $replace(Subterms, Vs1, Vs2, Index) .
		
	op integrate : Term TLIndexPair -> TLIndexPair .
	eq integrate(T, < TL , Index >) = < (T , TL) , Index > .
			
		
	op appAndInsSubst : Bool Nat Term Term Substitution AppSubstResult -> AppSubstResult .
	ceq appAndInsSubst(Mode, EKey, MIn, In, Sigma, < Calls , SMInVecs >) =
		if inSmallerSize(SMIn, In) *** * (size(SMIn) < size(In)) 
		then < Calls , (< EKey , SMIn > , SMInVecs) >
		else (if Mode
			  then (if inSmallerSize(In, SMIn) *** * (size(SMIn) > size(In))
			  		then   *** < none , none > 
						  < callsInc , (< EKey , SMIn > , SMInVecs) >
					else (if (Calls == callsRed)
						  then < callsEq , (< EKey , SMIn > , SMInVecs) >
						  else < Calls , (< EKey , SMIn > , SMInVecs) >
						  fi)
					fi)
			  else < none , none >
			  fi)
		fi
		if SMIn := (MIn Sigma) .
		   
		
		
		
	*** EINEN MATCH HINZUFUEGEN ************************************************
	*** introduceMatch und Hilfsfunktionen
	****************************************************************************
		
	op introduceMatch : Qid Qid Nat Term FunNameSet KeySet AppSubstResult
						MatchesIntroResult Coarities -> MatchesIntroResult .
	*** possibly outputs couldn't be matched or the match leads to unallowed MInVecs, then there are no MInVecs
	eq introduceMatch(Matched, Name, DKey, Pattern, Matchable, EKeys, 
					  < none , none >, Result, Coas) = Result .
	ceq introduceMatch(Matched, Name, DKey, Pattern, Matchable, EKeys, 
					   < Calls , (< EKey , 'in [ MIns ] > , MInVecs) >, 
					   < Matches , Rules , RC , IOSubsets , DC , Expls , FC >, Coas) =
		< (< (RC , RKeys) , (Name Calls Matched), funNameList2Set(ArgNames), 
			 Finished > , Matches) ,
		  (rule(RC, Name, DKey, Matched [ codeArgs(ArgNames, Pattern) ], noName, 
		  		noSubData, empty, true) , UpdRules) , 
		  UpdRC , (IOSubset , UpdIOSubsets) , UpdDC , UpdExpls , (FC + length(MIns)) >
		if ArgNames := createArgNames(FC, length(MIns)) /\
		   UpdExpls := introduceOutputs((< EKey , 'in [ MIns ] > , MInVecs), 
		   								ArgNames, Expls) /\
		   < ArgDKey , 
			 (ioData(ArgDKey, EKeys, ID, ODS, nil, Preds, Parts, PParts) , UpdIOSubsets) , 
		   	 UpdDC > :=
			introduceIOData(DC, EKeys, UpdExpls, Coas, IOSubsets) /\
		   < RKeys , UpdRules , UpdRC , Finished , IOSubset > :=
		   	introduceArgRules(ArgNames, ioData(ArgDKey, EKeys, ID, ODS, nil, Preds, Parts, PParts),
							  UpdExpls, Coas, Rules, s RC, Matchable) .			 	
		
	op codeArgs : FunNameList Term -> TermList .
	eq codeArgs(noName, 'in [ Subterms ]) = empty .
	eq codeArgs((Name ** ArgNames), 'in [ Subterms ]) = 
		Name [ Subterms ] , codeArgs(ArgNames, 'in [ Subterms ]) .
		
	op createArgNames : Nat Nat -> FunNameList .
	eq createArgNames(FC, 0) = noName .
	eq createArgNames(FC, Num) = 
		createSubname(FC) ** createArgNames(s FC, sd(Num, 1)) .
		
	op introduceOutputs : IndexedTerms FunNameList IOSet -> IOSet .
	eq introduceOutputs(none, ArgNames, Expls) = Expls .
	eq introduceOutputs((< EKey , 'in [ NewOuts ] > , MInVecs), ArgNames, 
						(ioEntry(EKey, I, NOs) , Expls)) =
		introduceOutputs(MInVecs, ArgNames, 
						 (ioEntry(EKey, I, 
						 		  (compNOs(EKey, NewOuts, ArgNames) , NOs)) ,
						  Expls)) .
						  
	op compNOs : Nat TermList FunNameList -> NamedOutputs .
	eq compNOs(EKey, empty, noName) = none .
	eq compNOs(EKey, (NewOut , NewOuts), (Name ** ArgNames)) =
		< Name , NewOut > , compNOs(EKey, NewOuts, ArgNames) .
		
	sort ArgRulesIntroResult .
	op <_,_,_,_,_> : KeySet RuleDataSet Nat Bool IOData -> ArgRulesIntroResult [ctor] .
	
	op introduceArgRules : FunNameList IOData IOSet Coarities RuleDataSet Nat FunNameSet
		-> ArgRulesIntroResult .
	eq introduceArgRules(noName, IOSubset, Expls, Coas, Rules, RC, Matchable) =
		< empty , Rules , RC , true , IOSubset > .
	ceq introduceArgRules((Name ** ArgNames), ioData(DKey, EKeys, ID, ODS, nil, Preds, Parts, PParts),
	  					  Expls, Coas, Rules, RC, Matchable) =
		< (RKey , RKeys) , ResultRules , ResultRC , (Finished and FragFinished) , 
		  UpdIOSubset >
		if < RHS , Finished , IOSubset > :=
			introduceOutData(Name, 
							 ioData(DKey, EKeys, ID, ODS, nil, Preds, Parts, PParts),
							 Expls, Coas) /\
		   < RKey , UpdRules , UpdRC > :=
		   	introduceRule(RC, Name, DKey, RHS, (Matchable * Name), Finished, Rules) /\
		   < RKeys , ResultRules , ResultRC , FragFinished , UpdIOSubset > :=
		   	introduceArgRules(ArgNames, IOSubset, Expls, Coas, UpdRules, UpdRC, Matchable) .
		   	
	****************************************************************************
		   
endfm
