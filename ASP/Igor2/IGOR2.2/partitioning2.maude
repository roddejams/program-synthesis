fmod PARTITIONS is
	inc SHARED-IO-DATA .
	inc MAIN-PARAMETERS .
	
	sort PartitionsResult .		*** result of compPartitions
	
	op <_;_;_> : Partitions IODataSet Nat 
				*** partitions, updated iodataset, updated dc
					-> PartitionsResult [ctor] .
	
	*** auxilliary sorts
	sort Partition .	*** set of AnnoteKeySet
	subsort AnnoteKeySet < Partition .
	
	op empty : -> Partition [ctor] .
	op _,_ : Partition Partition -> Partition 
			[ctor assoc comm id: empty] .
	eq A:AnnoteKeySet , A:AnnoteKeySet = A:AnnoteKeySet .
	
	
	vars EKeys DKeys : KeySet .
	var SD : SubstitutionData .
	vars IOSubsets UpdIOSubsets ResultIOSubsets : IODataSet .
	vars DC UpdDC ResultDC EKey EKey1 EKey2 DKey : Nat .
	var Expls : IOSet .
	var Coas : Coarities .
	var Mode : PartMode .
	var V : Variable .
	var ISubts : IndexedTerms .
	var Positions : Positions .
	var Parts : Partitions .
	var AD : AssignmentData .
	var Subterm : Term .
	vars Root PivotSym : Qid .
	var Part : Partition .
	var Pattern : AUResult .
	var ODS : OutDataSet .
	var Preds : TermList .
	var OnePart : Partitions .
	
	*** calls one of two functions for computing partitions				  
	op compPartitions : KeySet SubstitutionData IODataSet Nat IOSet Coarities PartMode
							-> PartitionsResult .
	eq compPartitions(EKeys, SD, IOSubsets, DC, Expls, Coas, Mode) = 
		compPartitions(EKeys, SD, IOSubsets, DC, Expls, Coas) .
		*** if Mode == medium
		*** then compPartitions(EKeys, SD, IOSubsets, DC, Expls, Coas)
		*** else compOnePartition(EKeys, SD, IOSubsets, DC, Expls, Coas)
		*** fi .
		
	*** partitions are computed w.r.t single generalized positions in the pattern,
	*** a position will be specialized only if no variable occurs at this
	*** position in subsumed inputs and the specialization is complete,
	*** i.e., medium mode
	*** for each subset of example keys it is checked whether an iodata for
	*** this set already exists, if not, a new one is initialized
	*** by initIOData-function
	op compPartitions : KeySet SubstitutionData IODataSet Nat IOSet Coarities 
							-> PartitionsResult .
							
	*** base case: no variable remaining in substitution data
	eq compPartitions(EKeys, empty, IOSubsets, DC, Expls, Coas) = 
		< noParts ; IOSubsets ; DC > .
		
	*** recursive case: compute partition regarding first variable, 
	*** compute partitions regarding remaining variables,
	*** combine results
	ceq compPartitions(EKeys, (< V ; ISubts ; Positions > , SD), IOSubsets, DC, 
					   Expls, Coas) =
		< (OnePart next Parts) ; ResultIOSubsets ; ResultDC >
		if < OnePart ; UpdIOSubsets ; UpdDC > := 
			compPartition(EKeys, < V ; ISubts ; Positions >, IOSubsets, DC, 
						  Expls, Coas) /\
		   < Parts ; ResultIOSubsets ; ResultDC > :=
			compPartitions(EKeys, SD, UpdIOSubsets, UpdDC, Expls, Coas) .
		
	*** computes one partition regarding one variable ($compPartition) and
	*** introduces iodata (finishPartition)
	op compPartition : KeySet AssignmentData IODataSet Nat IOSet Coarities 
							-> PartitionsResult .
	eq compPartition(EKeys, < V ; ISubts ; Positions >, IOSubsets, DC, 
					 Expls, Coas) = 
		if noVar(ISubts)
		then finishPartition($compPartition(EKeys, < V ; ISubts ; Positions >), 
							 IOSubsets, DC, Expls, Coas) 
		else < noParts ; IOSubsets ; DC >
		fi .
		
	op noVar : IndexedTerms -> Bool .
	eq noVar((< EKey , V > , ISubts)) = false .
	eq noVar(ISubts) = true [owise] .
		
	op $compPartition : KeySet AssignmentData -> Partition .
	
	*** base case: only one remaining example(key)
	eq $compPartition(EKey, < V ; < EKey , Subterm > ; Positions >) =
		< EKey ; root(Subterm) > .
	*** rec. case: compute partition regarding remaining example(key)s and
	*** insert the first key into the correct subset
	eq $compPartition((EKey1 , EKey2 , EKeys), 
			     	  < V ; (< EKey1 , Subterm > , ISubts) ; Positions >) =
		insert(EKey1, root(Subterm), 
			$compPartition((EKey2 , EKeys), < V ; ISubts ; Positions >)) .
						  
	*** inserts an example key regarding its pivot symbol into the correct
	*** subset of a partition, potentially into a new subset
	op insert : Nat Qid Partition -> Partition .
	eq insert(EKey, Root, (< EKeys ; Root > , Part)) = 
		< (EKey , EKeys) ; Root > , Part .
	eq insert(EKey, Root, Part) = < EKey ; Root > , Part [owise] .

	*** computes updated iodataset from a partition
	op finishPartition : Partition IODataSet Nat IOSet Coarities 
							-> PartitionsResult .
							
	*** base case: empty partition/no subsets
	eq finishPartition(empty, IOSubsets, DC, Expls, Coas) = 
		< empty ; IOSubsets ; DC > .
		
	*** rec. case: iodata for first explkey set exists already
	*** ceq finishPartition((< EKeys ; PivotSym > , Part), 
	*** *					(ioData(DKey, EKeys, Pattern, ODS, Preds, Parts) , IOSubsets),
	***					DC, Expls, Coas) =
	***	< (DKey , DKeys) , ResultIOSubsets , ResultDC >
	***	if < DKeys , ResultIOSubsets , ResultDC > :=
	***		finishPartition(Part, 
	*** *						(ioData(DKey, EKeys, Pattern, ODS, Preds, Parts) , IOSubsets), 
	***						DC, Expls, Coas) .
							
	*** rec. case: iodata for first explkey set doesn't exist
	ceq finishPartition((< EKeys ; PivotSym > , Part), IOSubsets,
						DC, Expls, Coas) =
		< (DKey , DKeys) ; ResultIOSubsets ; ResultDC >
		if < DKey , UpdIOSubsets , UpdDC > :=
		   	introduceIOData(DC, EKeys, Expls, Coas, IOSubsets) /\
		   < DKeys ; ResultIOSubsets ; ResultDC > :=
			finishPartition(Part, 
							UpdIOSubsets, 
							UpdDC, Expls, Coas) .
							
endfm


fmod PARTITIONING is
	inc PARTITIONS .
	inc HYPOTHESES .
	
	sorts Fragment FragmentSet .	*** as Program but without the calling relations,
					*** represents rules replaced for a rule
	subsort Fragment < FragmentSet .
	
	op frag : KeySet Nat Bool		
		*** rule keys, keys of io subsets (specialization grade), finished
				-> Fragment [ctor] .
	op empty : -> FragmentSet [ctor] .
	op _,_ : FragmentSet FragmentSet -> FragmentSet [ctor assoc comm id: empty] .
	eq F:Fragment , F:Fragment = F:Fragment .
	
	sort FragmentsResult .
	op <_,_,_,_> : FragmentSet RuleDataSet Nat IODataSet 
				*** computed fragments, updated rule set, updated rule counter,
				*** updated io subsets; io subsets may change because out data 
				*** is introduced if not yet present 
					-> FragmentsResult .
					
	
	vars RKey DKey RC UpdRC ResultRC DC UpdDC EC FC VarIndex Speci FSpeci PSpeci : Nat .
	var Name : Qid .
	vars RHS Pattern : Term .
	var Matchable CNames : FunNameSet .
	vars Progs UpdProgs : ProgramSet .
	vars Rules UpdRules ResultRules : RuleDataSet .
	vars EKeys RKeys NewKeys Part DKeys : KeySet .
	var SD : SubstitutionData .
	var ODS : OutDataSet .
	var Preds : TermList .
	var Parts : Partitions .
	vars IOSubsets UpdIOSubsets ResultIOSubsets : IODataSet .
	var Coas : Coarities .
	var Mode : PartMode .
	var Frags : FragmentSet .
	vars Cs : CallPairSet .
	vars Finished FragFinished : Bool .
	var Frag : Fragment .
	var Expls : IOSet .
	var ID : AUResult .
	var Data : IOData .
	var Prog : Program .
	var Sub : SubData .
	var Matches : MatchDataSet .
	
	
	*** computes a program fragment for each partition
	op compFragments : Partitions IODataSet IOSet Nat Qid FunNameSet RuleDataSet Coarities
						-> FragmentsResult .
						
	*** base case: no partitions
	eq compFragments(noParts, IOSubsets, Expls, RC, Name, Matchable, Rules, Coas) = 
		< empty , Rules , RC , IOSubsets > .
		
	*** rec. case
	ceq compFragments((Part next Parts), IOSubsets, Expls, RC, Name, Matchable, Rules, Coas) =
		< (Frag , Frags) , 
		  ResultRules ,
		  ResultRC ,
		  ResultIOSubsets >
		if < Frag , UpdRules , UpdRC , UpdIOSubsets > :=
			compFragment(Part, IOSubsets, Expls, RC, Name, Matchable, Rules, Coas) /\
		   < Frags , ResultRules , ResultRC , ResultIOSubsets > := 
			compFragments(Parts, UpdIOSubsets, Expls, UpdRC, Name, Matchable, UpdRules, Coas) .
		
	*** computes the fragment for one partition
	op compFragment : KeySet IODataSet IOSet Nat Qid FunNameSet RuleDataSet Coarities
						-> FragmentsResult .
	*** base case (no remaining data keys)
	eq compFragment(empty, IOSubsets, Expls, RC, Name, Matchable, Rules, Coas) =
		< frag(empty, 0, true) , Rules , RC , IOSubsets > .
	*** rec. case
	ceq compFragment((DKey , DKeys), 
					 (ioData(DKey, EKeys, ID, ODS, Preds, Parts) , IOSubsets), 
					 Expls, RC, Name, Matchable, Rules, Coas) =
		< frag((RKey , RKeys) , s Speci , (Finished and FragFinished)) ,
		  ResultRules , 
		  ResultRC , 
		  ResultIOSubsets >
		if < RHS , Finished , Data > := 
			introduceOutData(Name, ioData(DKey, EKeys, ID, ODS, Preds, Parts), 
							 Expls, Coas) /\
		   < RKey , UpdRules , UpdRC > := 
		   	introduceRule(RC, Name, DKey, RHS, Matchable, Finished, Rules) /\
		   < frag(RKeys, Speci, FragFinished) , 
		     ResultRules , 
		     ResultRC ,
		     ResultIOSubsets > :=
		   	compFragment(DKeys, (Data , IOSubsets), Expls, UpdRC, Name, 
		   				 Matchable, UpdRules, Coas) .


	op $integrateFragments : Nat FragmentSet Program RuleDataSet Qid -> ProgramSet .
	eq $integrateFragments(RKey, empty, Prog, Rules, Name) = empty .
	eq $integrateFragments(RKey, (frag(NewKeys, FSpeci, Finished) , Frags), 
						   prog((RKey , RKeys), Cs, PSpeci, CNames, false), 
						   Rules, Name) =
		(prog((NewKeys , RKeys), Cs, 
			  (sd(PSpeci, 1) + FSpeci),
			  (CNames * Name),
			  (finished(RKeys, Rules) and Finished)) ,
		 $integrateFragments(RKey, Frags, 
							 prog((RKey , RKeys), Cs, PSpeci, CNames, false),
						     Rules, Name)) .		    
		
	*** replaces given rule key by keys in the fragment in all programs
	*** and updates finished and specialization info
	op integrateFragments : Nat FragmentSet ProgramSet RuleDataSet Qid -> ProgramSet .
	
	*** a program containing the rule exists, then replace with fragments and
	*** proceed on remaining programs
	eq integrateFragments(RKey, Frags, 
						  (prog((RKey , RKeys), Cs, Speci, CNames, false) , Progs),
						  Rules, Name) = 
		$integrateFragments(RKey, Frags, 
						    prog((RKey , RKeys), Cs, Speci, CNames, false),
						    Rules, Name) ,
		integrateFragments(RKey, Frags, Progs, Rules, Name) .
		
	*** no program containing the rule exists, return programs unchanged
	eq integrateFragments(RKey, Frags, Progs, Rules, Name) = Progs [owise] .
	
	
	op partitioning : Nat InductionState Coarities PartMode -> InductionState .
	
	*** partitions exist already
	*** then the corresponding IOSubsets exists already but will be updated,
	*** thus, the DC will remain the same
	ceq partitioning(RKey, 
			 istate(Progs, (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, false) , Rules), RC, 
					  	    (ioData(DKey, EKeys, ID, ODS, Preds, (Part next Parts)) , 
						   	 IOSubsets),
						    DC, Expls, EC, FC),
					 Coas, Mode) =
		istate(integrateFragments(RKey, Frags, Progs, UpdRules, Name), UpdRules, UpdRC, 
			   (ioData(DKey, EKeys, ID, ODS, Preds, (Part next Parts)) , 
				ResultIOSubsets),
				DC, Expls, EC, FC)
		if < Frags , UpdRules , UpdRC , ResultIOSubsets > :=
		   	compFragments((Part next Parts), IOSubsets, Expls, RC, Name, Matchable, 
				      (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, false) , Rules), Coas) .
	
	*** partitions doesn't exist
	ceq partitioning(RKey,
			 istate(Progs, (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, false) , Rules), RC, 
						    (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, 
						   		    ODS, Preds, noParts) , 
						   	 IOSubsets),
						    DC, Expls, EC, FC),
					 Coas, Mode) =
		istate(integrateFragments(RKey, Frags, Progs, UpdRules, Name), UpdRules, UpdRC, 
			   (ioData(DKey, EKeys, < Pattern , SD , VarIndex >, 
					   ODS, Preds, Parts) , 
				ResultIOSubsets),
				UpdDC, Expls, EC, FC)
		if < Parts ; UpdIOSubsets ; UpdDC > := 
			compPartitions(EKeys, SD, IOSubsets, DC, Expls, Coas, Mode) /\
		   < Frags , UpdRules , UpdRC , ResultIOSubsets > :=
		   	compFragments(Parts, UpdIOSubsets, Expls, RC, Name, Matchable, 
				      (rule(RKey, Name, DKey, RHS, Matchable, Sub, Matches, false) , Rules), Coas) .
		   

endfm
