fmod PATH is
	sorts MyItem MyList MyTree InVec .

	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	op leaf : -> MyTree [ctor] .
	op <_,_,_> : MyTree MyItem MyTree -> MyTree [ctor] .

	op a : -> MyItem [ctor] .
	op b : -> MyItem [ctor] .
	op c : -> MyItem [ctor] .

	op Path : MyItem MyTree -> MyList [metadata "induce"] .
	op in : MyItem MyTree -> InVec [ctor] .

	eq Path(a, < leaf , a , < leaf , b , < leaf , c , leaf > > >) =
		cons(a,[]) .
	eq Path(b, < leaf , a , < leaf , b , < leaf , c , leaf > > >) =
		cons(b,cons(a,[])) .
	eq Path(c, < leaf , a , < leaf , b , < leaf , c , leaf > > >) =
		cons(c, cons(b,cons(a,[]))) .
endfm

fmod LAST is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Last : MyList -> MyItem [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V : MyItem .

	*** examples
	eq Last(cons(X,[])) = X .
	eq Last(cons(X,cons(Y,[]))) = Y .
	eq Last(cons(X,cons(Y,cons(Z,[])))) = Z .
	*** eq Last(cons(X,cons(Y,cons(Z,cons(V,[]))))) = V .
endfm

fmod LASTS is
	sorts MyItem MyList MyOuterList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	op emptyo : -> MyOuterList [ctor] .
	op conso : MyList MyOuterList -> MyOuterList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Lasts : MyOuterList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyOuterList -> InVec [ctor] .

	vars X Y Z V W : MyItem .

	*** examples
	eq Lasts(emptyo) = [] .
	eq Lasts(conso(cons(X,[]),emptyo)) = cons(X,[]) .
	eq Lasts(conso(cons(X,cons(Y,[])),emptyo)) = cons(Y,[]) .
	eq Lasts(conso(cons(X,cons(Y,cons(Z,[]))),emptyo)) = cons(Z,[]) .

	eq Lasts(conso(cons(X,[]),conso(cons(Y,[]),emptyo))) =
		cons(X,cons(Y,[])) .
	eq Lasts(conso(cons(X,cons(Y,[])),conso(cons(Z,[]),emptyo))) =
		cons(Y,cons(Z,[])) .
	eq Lasts(conso(cons(X,cons(Y,cons(Z,[]))),conso(cons(V,[]),emptyo))) =
		 cons(Z,cons(V,[])) .

	eq Lasts(conso(cons(X,[]),conso(cons(Y,cons(Z,[])),emptyo))) =
		cons(X,cons(Z,[])) .
	eq Lasts(conso(cons(X,cons(Y,[])),conso(cons(Z,cons(V,[])),emptyo))) =
		cons(Y,cons(V,[])) .
	eq Lasts(conso(cons(X,cons(Y,cons(Z,[]))),conso(cons(V,cons(W,[])),emptyo))) =
		 cons(Z,cons(W,[])) .
endfm




fmod STRING-TEST is
	inc STRING .

	sorts MyList InVec .

	op [] : -> MyList [ctor] .
	op cons : String MyList -> MyList [ctor] .

	***ops "eins" "zwei "drei" : -> String [ctor] .

	op Rev : MyList -> MyList [metadata "induce"] .
	op in : MyList -> InVec [ctor] .

	eq Rev([]) = [] .
	eq Rev(cons("eins",[])) = cons("eins",[]) .
	eq Rev(cons("zwei",[])) = cons("zwei",[]) .
	eq Rev(cons("drei",[])) = cons("drei",[]) .

	eq Rev(cons("eins",cons("zwei",[]))) = cons("zwei",cons("eins",[])) .
	eq Rev(cons("zwei",cons("eins",[]))) = cons("eins",cons("zwei",[])) .
	eq Rev(cons("eins",cons("drei",[]))) = cons("drei",cons("eins",[])) .
	eq Rev(cons("drei",cons("eins",[]))) = cons("eins",cons("drei",[])) .
	eq Rev(cons("zwei",cons("drei",[]))) = cons("drei",cons("zwei",[])) .
	eq Rev(cons("drei",cons("zwei",[]))) = cons("zwei",cons("drei",[])) .

	eq Rev(cons("eins",cons("zwei",cons("drei",[])))) =
		cons("drei",cons("zwei",cons("eins",[]))) .
	***eq Rev(cons("drei",cons("zwei",cons("eins",[])))) =
	***	cons("eins",cons("zwei",cons("drei",[]))) .
endfm

fmod PREPROC is
	sorts MyList MyItem MySep InVec .

	op [] : -> MyList [ctor] .
	op cons1 : MyItem MyList -> MyList [ctor] .
	op cons2 : MySep MyList -> MyList [ctor] .
	ops a b c d : -> MyItem [ctor] .
	op s : -> MySep [ctor metadata "separator nomatch"] .

	op Test : MyList -> MyList [metadata "induce"] .
	op in : MyList -> InVec [ctor] .

	eq Test([]) = [] .
	eq Test(cons1(a,[])) = cons1(a,[]) .
	eq Test(cons1(b,[])) = cons1(b,[]) .
	eq Test(cons1(a,cons2(s,cons1(b,[])))) = cons1(b,cons2(s,cons1(a,[]))) .
	eq Test(cons1(b,cons2(s,cons1(a,[])))) = cons1(a,cons2(s,cons1(b,[]))) .
	eq Test(cons1(a,cons2(s,cons1(b,cons2(s,cons1(c,[])))))) =
		cons1(c,cons2(s,cons1(b,cons2(s,cons1(a,[]))))) .
	eq Test(cons1(b,cons2(s,cons1(c,cons2(s,cons1(a,[])))))) =
		cons1(a,cons2(s,cons1(c,cons2(s,cons1(b,[]))))) .
	eq Test(cons1(a,cons2(s,cons1(b,cons2(s,cons1(c,cons2(s,cons1(d,[])))))))) =
		cons1(d,cons2(s,cons1(c,cons2(s,cons1(b,cons2(s,cons1(a,[]))))))) .
	eq Test(cons1(b,cons2(s,cons1(c,cons2(s,cons1(d,cons2(s,cons1(a,[])))))))) =
		cons1(a,cons2(s,cons1(d,cons2(s,cons1(c,cons2(s,cons1(b,[]))))))) .
endfm


fmod INIT is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Init : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq Init(cons(X,[])) = [] .
	eq Init(cons(X,cons(Y,[]))) = cons(X,[]) .
	eq Init(cons(X,cons(Y,cons(Z,[])))) =  cons(X,cons(Y,[])) .
endfm


fmod SNOC is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Snoc : MyList MyItem -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList MyItem -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq Snoc([],Z) = cons(Z,[]) .
	eq Snoc(cons(X,[]),Z) = cons(X,cons(Z,[])) .
	eq Snoc(cons(X,cons(Y,[])),Z) = cons(X,cons(Y,cons(Z,[]))) .
endfm


fmod EVENPOS is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Evenpos : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V : MyItem .

	*** examples
	eq Evenpos([]) = [] .
	eq Evenpos(cons(X,[])) = [] .
	eq Evenpos(cons(X,cons(Y,[]))) = cons(Y,[]) .
	eq Evenpos(cons(X,cons(Y,cons(Z,[])))) =  cons(Y,[]) .
	eq Evenpos(cons(X,cons(Y,cons(Z,cons(V,[]))))) =  cons(Y,cons(V,[])) .
endfm


fmod SWITCH is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Switch : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V : MyItem .

	*** examples
	***eq Switch([]) = [] .
	eq Switch(cons(X,[])) = cons(X,[]) .
	eq Switch(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq Switch(cons(X,cons(Y,cons(Z,[])))) =  cons(Y,cons(X,cons(Z,[]))) .
	eq Switch(cons(X,cons(Y,cons(Z,cons(V,[]))))) =  cons(Y,cons(X,cons(V,cons(Z,[])))) .
endfm


fmod SWAP is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Swap : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V W : MyItem .

	*** examples
	eq Swap([]) = [] .
	eq Swap(cons(X,[])) = cons(X,[]) .
	eq Swap(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq Swap(cons(X,cons(Y,cons(Z,[])))) =  cons(Z,cons(Y,cons(X,[]))) .
	eq Swap(cons(X,cons(Y,cons(Z,cons(V,[]))))) =  cons(V,cons(Y,cons(Z,cons(X,[])))) .
	eq Swap(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) =  cons(W,cons(Y,cons(Z,cons(V,cons(X,[]))))) .
endfm


fmod LENGTH is
	sorts MyItem MyList MyNat InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Length : MyList -> MyNat [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y : MyItem .

	eq Length([]) = 0 .
	eq Length(cons(X,[])) = s(0) .
	eq Length(cons(X,cons(Y,[]))) = s(s(0)) .
endfm

fmod EVENLENGTH is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	***op t : -> MyBool [ctor] .
	***op f : -> MyBool [ctor] .

	op Evenlength : MyList -> Bool [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z : MyItem .

	eq Evenlength([]) = true .
	eq Evenlength(cons(X,[])) = false .
	eq Evenlength(cons(X,cons(Y,[]))) = true .
	eq Evenlength(cons(X,cons(Y,cons(Z,[])))) = false .
endfm


fmod ODD is
	sorts MyNat MyBool InVec .

	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .
	op t : -> MyBool [ctor] .
	op f : -> MyBool [ctor] .

	op Odd : MyNat -> MyBool [metadata "induce"] .
	op in : MyNat -> InVec [ctor] .

	eq Odd(0) = f .
	eq Odd(s(0)) = t .
	eq Odd(s(s(0))) = f .
	eq Odd(s(s(s(0)))) = t .
	***eq Odd(s(s(s(s(0))))) = f .
endfm


fmod EVENODD is
	sorts MyNat MyBool InVec .

	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .
	op t : -> MyBool [ctor] .
	op f : -> MyBool [ctor] .

	op Even : MyNat -> MyBool [metadata "induce"] .
	op Odd : MyNat -> MyBool [metadata "induce"] .
	op in : MyNat -> InVec [ctor] .

	eq Even(0) = t .
	eq Even(s(0)) = f .
	eq Even(s(s(0))) = t .

	eq Odd(0) = f .
	eq Odd(s(0)) = t .
	eq Odd(s(s(0))) = f .
	***eq Odd(s(s(s(0)))) = t .
endfm


fmod TAKE is
	sorts MyItem MyList MyNat InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Take : MyList MyNat -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList MyNat -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq Take([],0) = [] .
	eq Take(cons(X,[]),0) = [] .
	eq Take(cons(X,[]),s(0)) = cons(X,[]) .
	eq Take(cons(X,cons(Y,[])),0) = [] .
	eq Take(cons(X,cons(Y,[])),s(0)) = cons(X,[]) .
	eq Take(cons(X,cons(Y,[])),s(s(0))) = cons(X,cons(Y,[])) .
	***eq Take(cons(X,cons(Y,cons(Z,[])))) =  cons(X,cons(Y,[])) .
endfm


fmod SUM is
	sorts MyList MyNat InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Sum : MyList -> MyNat [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	eq Sum([]) = 0 .
	eq Sum(cons(0,[])) = 0 .
	eq Sum(cons(s(0),[])) = s(0) .
	eq Sum(cons(0,cons(0,[]))) = 0 .
	eq Sum(cons(0,cons(s(0),[]))) = s(0) .
	eq Sum(cons(s(0),cons(0,[]))) = s(0) .
	eq Sum(cons(s(0),cons(s(0),[]))) = s(s(0)) .
	eq Sum(cons(s(s(0)),cons(0,[]))) = s(s(0)) .
endfm


fmod REVERSE-CONST is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	ops a b c d : -> MyItem [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Reverse : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	*** vars X Y Z V : MyItem .

	*** examples
	eq Reverse([]) = [] .
	eq Reverse(cons(a,[])) = cons(a,[]) .
	eq Reverse(cons(b,[])) = cons(b,[]) .
	eq Reverse(cons(c,[])) = cons(c,[]) .
	eq Reverse(cons(a,cons(b,[]))) = cons(b,cons(a,[])) .
	***eq Reverse(cons(a,cons(c,[]))) = cons(c,cons(a,[])) .
	***eq Reverse(cons(b,cons(a,[]))) = cons(a,cons(b,[])) .
	***eq Reverse(cons(b,cons(c,[]))) = cons(c,cons(b,[])) .
	eq Reverse(cons(a,cons(b,cons(c,[])))) = cons(c,cons(b,cons(a,[]))) .
	***eq Reverse(cons(a,cons(c,cons(b,[])))) = cons(b,cons(c,cons(a,[]))) .
	***eq Reverse(cons(b,cons(a,cons(c,[])))) = cons(c,cons(a,cons(b,[]))) .
	***eq Reverse(cons(b,cons(c,cons(a,[])))) = cons(a,cons(c,cons(b,[]))) .
	***eq Reverse(cons(c,cons(a,cons(b,[])))) = cons(b,cons(a,cons(c,[]))) .
	***eq Reverse(cons(c,cons(b,cons(a,[])))) = cons(a,cons(b,cons(c,[]))) .
	eq Reverse(cons(d,cons(a,cons(b,[])))) = cons(b,cons(a,cons(d,[]))) .
	eq Reverse(cons(d,cons(a,[]))) = cons(a,cons(d,[])) .
	eq Reverse(cons(d,[])) = cons(d,[]) .

	eq Reverse(cons(d,cons(a,cons(b,cons(c,[]))))) =
		cons(c,cons(b,cons(a,cons(d,[])))) .
endfm


fmod REVERSE is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Reverse : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V : MyItem .

	*** examples
	eq Reverse([]) = [] .
	eq Reverse(cons(X,[])) = cons(X,[]) .
	eq Reverse(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq Reverse(cons(X,cons(Y,cons(Z,[])))) = cons(Z,cons(Y,cons(X,[]))) .
	eq Reverse(cons(X,cons(Y,cons(Z,cons(V,[]))))) = cons(V,cons(Z,cons(Y,cons(X,[])))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) = cons(W,cons(V,cons(Z,cons(Y,cons(X,[]))))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,cons(Q,[]))))))) = cons(Q,cons(W,cons(V,cons(Z,cons(Y,cons(X,[])))))) .
endfm


*** doesn't work yet because the recursive call in reverse-aux is equal
*** to the pattern regarding the total size of symbols! only the first parameter
*** reduces (the second, aux, increases). with the alternative red-order
*** applied by FFOIL this would work (as well as ackermann)
fmod REV-AUX is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Reverse : MyList MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList MyList -> InVec [ctor] .

	vars X Y Z : MyItem .
	var L : MyList .

	*** examples
	eq Reverse([],L) = L .
	eq Reverse(cons(X,[]),L) = cons(X,L) .
	eq Reverse(cons(X,cons(Y,[])),L) = cons(Y,cons(X,L)) .
	eq Reverse(cons(X,cons(Y,cons(Z,[]))),L) = cons(Z,cons(Y,cons(X,L))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,[])))),L) = cons(V,cons(Z,cons(Y,cons(X,L)))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) = cons(W,cons(V,cons(Z,cons(Y,cons(X,[]))))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,cons(Q,[]))))))) = cons(Q,cons(W,cons(V,cons(Z,cons(Y,cons(X,[])))))) .
endfm




fmod SHIFT-R is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op ShiftR : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq ShiftR([]) = [] .
	eq ShiftR(cons(X,[])) = cons(X,[]) .
	eq ShiftR(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq ShiftR(cons(X,cons(Y,cons(Z,[])))) = cons(Z,cons(X,cons(Y,[]))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,[]))))) = cons(V,cons(Z,cons(Y,cons(X,[])))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) = cons(W,cons(V,cons(Z,cons(Y,cons(X,[]))))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,cons(Q,[]))))))) = cons(Q,cons(W,cons(V,cons(Z,cons(Y,cons(X,[])))))) .
endfm


fmod SHIFT-L is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op ShiftL : MyList -> MyList [metadata "induce"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq ShiftL([]) = [] .
	eq ShiftL(cons(X,[])) = cons(X,[]) .
	eq ShiftL(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq ShiftL(cons(X,cons(Y,cons(Z,[])))) = cons(Y,cons(Z,cons(X,[]))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,[]))))) = cons(V,cons(Z,cons(Y,cons(X,[])))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) = cons(W,cons(V,cons(Z,cons(Y,cons(X,[]))))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,cons(Q,[]))))))) = cons(Q,cons(W,cons(V,cons(Z,cons(Y,cons(X,[])))))) .
endfm


fmod MIRROR is
	sorts MyItem MyTree InVec .

	*** DT definitions (constructors)
	op leaf : -> MyTree [ctor] .
	op <_,_,_> : MyTree MyItem MyTree -> MyTree [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Mirror : MyTree -> MyTree [metadata "induce"] .
	*** input encapsulation
	op in : MyTree -> InVec [ctor] .

	vars X Y Z K A B C : MyItem .

	eq Mirror(leaf) = leaf .
	eq Mirror(< leaf , X , leaf >) = < leaf , X , leaf > .
	eq Mirror(< < leaf , X , leaf > , Y , < leaf , Z , leaf > >) =
		< < leaf , Z , leaf > , Y , < leaf , X , leaf > > .
	eq Mirror(< < < leaf , X , leaf > , Y , < leaf , Z , leaf > > , K , < < leaf , A , leaf > , B , < leaf , C , leaf > > >) =
		< < < leaf , C , leaf > , B , < leaf , A , leaf > > , K , < < leaf , Z , leaf > , Y , < leaf , X , leaf > > > .
endfm


fmod FLATTEN is
	sorts MyItem MyList MyTree InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	op leaf : -> MyTree [ctor] .
	op <_,_,_> : MyTree MyItem MyTree -> MyTree [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Flatten : MyTree -> MyList [metadata "induce"] .
	op Append : MyList MyList -> MyList [metadata ""] .
	*** input encapsulation
	op in : MyTree -> InVec [ctor] .
	op in : MyList MyList -> InVec [ctor] .

	vars X Y Z K A B C : MyItem .
	***var L : MyList .

	eq Flatten(leaf) = [] .
	eq Flatten(< leaf , X , leaf >) = cons(X,[]) .
	eq Flatten(< < leaf , X , leaf > , Y , < leaf , Z , leaf > >) =
		cons(X,cons(Y,cons(Z,[]))) .
	eq Flatten(< < < leaf , X , leaf > , Y , < leaf , Z , leaf > > , K , < < leaf , A , leaf > , B , < leaf , C , leaf > > >) =
		cons(X,cons(Y,cons(Z,cons(K,cons(A,cons(B,cons(C,[]))))))) .

	eq Append([],[]) = [] .
	eq Append([],cons(X,cons(Y,[]))) = cons(X,cons(Y,[])) .
	eq Append([],cons(X,cons(Y,cons(Z,[])))) = cons(X,cons(Y,cons(Z,[]))) .
	eq Append([],cons(X,cons(Y,cons(Z,cons(A,[]))))) = cons(X,cons(Y,cons(Z,cons(A,[])))) .

	eq Append(cons(X,[]),[]) =  cons(X,[]) .
	eq Append(cons(X,[]),cons(Y,[])) =  cons(X,cons(Y,[])) .
	eq Append(cons(A,[]),cons(X,cons(Y,cons(Z,[])))) = cons(A,cons(X,cons(Y,cons(Z,[])))) .
	eq Append(cons(B,[]),cons(X,cons(Y,cons(Z,cons(A,[]))))) = cons(B,cons(X,cons(Y,cons(Z,cons(A,[]))))) .

	eq Append(cons(X,cons(Y,[])),[]) =  cons(X,cons(Y,[])) .
	eq Append(cons(X,cons(Y,[])),cons(Z,[])) =  cons(X,cons(Y,cons(Z,[]))) .
	eq Append(cons(X,cons(Y,[])),cons(Z,cons(A,[]))) =  cons(X,cons(Y,cons(Z,cons(A,[])))) .
	eq Append(cons(B,cons(A,[])),cons(X,cons(Y,cons(Z,[])))) = cons(B,cons(A,cons(X,cons(Y,cons(Z,[]))))) .
	eq Append(cons(C,cons(B,[])),cons(X,cons(Y,cons(Z,cons(A,[]))))) = cons(C,cons(B,cons(X,cons(Y,cons(Z,cons(A,[])))))) .

	eq Append(cons(X,cons(Y,cons(Z,[]))),[]) =
		cons(X,cons(Y,cons(Z,[]))) .
	eq Append(cons(X,cons(Y,cons(Z,[]))),cons(C,[])) =
		cons(X,cons(Y,cons(Z,cons(C,[])))) .
	eq Append(cons(X,cons(Y,cons(Z,[]))),cons(B,cons(C,[]))) =
		cons(X,cons(Y,cons(Z,cons(B,cons(C,[]))))) .
	eq Append(cons(X,cons(Y,cons(Z,[]))),cons(A,cons(B,cons(C,[])))) =
		cons(X,cons(Y,cons(Z,cons(A,cons(B,cons(C,[])))))) .

	eq Append([],cons(X,[])) = cons(X,[]) .
	eq Append(cons(X,[]),cons(Y,cons(Z,[]))) = cons(X,cons(Y,cons(Z,[]))) .
	eq Append(cons(X,cons(Y,cons(Z,[]))),cons(K,cons(A,cons(B,cons(C,[]))))) =
		cons(X,cons(Y,cons(Z,cons(K,cons(A,cons(B,cons(C,[]))))))) .
endfm


fmod SORT is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Sort : MyList -> MyList [metadata "induce"] .
	op Ins : MyNat MyList -> MyList [metadata ""] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyNat MyList -> InVec [ctor] .


	var X : MyNat .

	eq Sort([]) = [] .

	eq Sort(cons(0,[])) = cons(0,[]) .
	eq Sort(cons(s(0),[])) = cons(s(0),[]) .
	***eq Sort(cons(s(s(0)),[])) = cons(s(s(0)),[]) .

	eq Sort(cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	***eq Sort(cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(0),cons(0,[]))) = cons(0,cons(s(0),[])) .
	***eq Sort(cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	***eq Sort(cons(s(s(0)),cons(0,[]))) = cons(0,cons(s(s(0)),[])) .
	***eq Sort(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),cons(s(s(0)),[])) .

	***eq Sort(cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(0,cons(s(s(0)),cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(0),cons(s(s(0)),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(s(0)),cons(0,cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .



	eq Ins(0,[]) = cons(0,[]) .
	eq Ins(s(0),[]) = cons(s(0),[]) .
	***eq Ins(s(s(0)),[]) = cons(s(s(0)),[]) .

	eq Ins(0,cons(s(0),[])) = cons(0,cons(s(0),[])) .
	eq Ins(0,cons(s(s(0)),[])) = cons(0,cons(s(s(0)),[])) .
	eq Ins(s(0),cons(0,[])) = cons(0,cons(s(0),[])) .
	eq Ins(s(0),cons(s(s(0)),[])) = cons(s(0),cons(s(s(0)),[])) .
	***eq Ins(s(s(0)),cons(0,[])) = cons(0,cons(s(s(0)),[])) .
	***eq Ins(s(s(0)),cons(s(0),[])) = cons(s(0),cons(s(s(0)),[])) .

	eq Ins(0,cons(s(0),cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(0),cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(s(0)),cons(0,cons(s(0),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm


fmod SORT2 is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Sort : MyList -> MyList [metadata "induce"] .
	op Ins : MyNat MyList -> MyList [metadata ""] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyNat MyList -> InVec [ctor] .

	eq Sort([]) = [] .

	vars X Y : MyNat .
	var L : MyList .

	***eq Sort(cons(0,[])) = cons(0,[]) .
	***eq Sort(cons(s(0),[])) = cons(s(0),[]) .
	***eq Sort(cons(s(s(0)),[])) = cons(s(s(0)),[]) .
	eq Sort(cons(X,[])) = cons(X,[]) .

	eq Sort(cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(0),cons(0,[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(0,[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),cons(s(s(0)),[])) .

	eq Sort(cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(0,cons(s(s(0)),cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(0),cons(s(s(0)),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(0,cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .



	***eq Ins(0,[]) = cons(0,[]) .
	***eq Ins(s(0),[]) = cons(s(0),[]) .
	***eq Ins(s(s(0)),[]) = cons(s(s(0)),[]) .
	eq Ins(X,[]) = cons(X,[]) .

	***eq Ins(0,cons(s(0),[])) = cons(0,cons(s(0),[])) .
	***eq Ins(0,cons(s(s(0)),[])) = cons(0,cons(s(s(0)),[])) .
	eq Ins(0,cons(Y,L)) = cons(0,cons(Y,L)) .
	eq Ins(s(0),cons(0,[])) = cons(0,cons(s(0),[])) .
	eq Ins(s(0),cons(s(s(0)),[])) = cons(s(0),cons(s(s(0)),[])) .
	eq Ins(s(s(0)),cons(0,[])) = cons(0,cons(s(s(0)),[])) .
	eq Ins(s(s(0)),cons(s(0),[])) = cons(s(0),cons(s(s(0)),[])) .

	***eq Ins(0,cons(s(0),cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(0),cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(s(0)),cons(0,cons(s(0),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm


fmod MULTI is
     sorts MyInner MyOuter MyElem InVec .

     op i[] : -> MyInner [ctor] .
     op icons : MyElem MyInner -> MyInner [ctor] .
     op o[] : -> MyOuter [ctor] .
     op ocons : MyInner MyOuter -> MyOuter [ctor] .

     op Multi : MyOuter -> MyOuter [metadata "induce"] .
     op in : MyOuter -> InVec [ctor] .

     vars X Y Z V W : MyElem .

     eq Multi(o[]) = o[] .

     eq Multi(ocons(icons(X,i[]), o[])) = ocons(icons(X,i[]), o[]) .
     eq Multi(ocons(icons(X,icons(Y,i[])), o[])) = ocons(icons(Y,i[]), o[]) .
     eq Multi(ocons(icons(X,icons(Y,icons(Z,i[]))), o[])) = ocons(icons(Z,i[]), o[]) .

     eq Multi(ocons(icons(X,i[]), ocons(i[], o[]))) = ocons(icons(X,i[]), ocons(i[], o[])) .
     eq Multi(ocons(icons(X,i[]), ocons(icons(Y,i[]), o[]))) = ocons(icons(X,i[]), ocons(icons(Y,i[]), o[])) .
     eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,i[])), o[]))) = ocons(icons(X,i[]), ocons(icons(Z,icons(Y,i[])), o[])) .
     ***eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,icons(V,i[]))), o[]))) = ocons(icons(X,i[]), ocons(icons(Z,icons(Y,icons(V,i[]))), o[])) .
     ***eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,icons(V,icons(W,i[])))), o[]))) = ocons(icons(X,i[]), ocons(icons(Z,icons(Y,icons(W,icons(V,i[])))), o[])) .
     eq Multi(ocons(icons(X,icons(Y,i[])), ocons(i[], o[]))) = ocons(icons(Y,i[]), ocons(i[], o[])) .
     ***eq Multi(ocons(icons(X,icons(Y,i[])), ocons(icons(Z,i[]), o[]))) = ocons(icons(Y,i[]), ocons(icons(Z,i[]), o[])) .

     ***eq Multi(ocons(icons(X,i[]), ocons(i[], ocons(icons(Y,i[]), o[])))) = ocons(icons(X,i[]), ocons(i[], ocons(icons(Y,i[]), o[]))) .
endfm


fmod MULTI2 is
     sorts MyInner MyOuter MyElem InVec .

     op i[] : -> MyInner [ctor] .
     op icons : MyElem MyInner -> MyInner [ctor] .
     op o[] : -> MyOuter [ctor] .
     op ocons : MyInner MyOuter -> MyOuter [ctor] .

     op Multi : MyOuter -> MyInner [metadata "induce"] .
     op in : MyOuter -> InVec [ctor] .

     vars X Y Z V W : MyElem .

     eq Multi(o[]) = i[] .

     eq Multi(ocons(icons(X,i[]), o[])) = icons(X, i[]) .
     eq Multi(ocons(icons(X,icons(Y,i[])), o[])) = icons(Y, i[]) .
     eq Multi(ocons(icons(X,icons(Y,icons(Z,i[]))), o[])) = icons(Z, i[]) .

     eq Multi(ocons(icons(X,i[]), ocons(icons(Y,i[]), o[]))) = icons(X, icons(Y, i[])) .
     eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,i[])), o[]))) = icons(X, icons(Y, i[])) .
     ***eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,icons(V,i[]))), o[]))) = ocons(icons(X,i[]), ocons(icons(Z,icons(Y,icons(V,i[]))), o[])) .
     ***eq Multi(ocons(icons(X,i[]), ocons(icons(Y,icons(Z,icons(V,icons(W,i[])))), o[]))) = ocons(icons(X,i[]), ocons(icons(Z,icons(Y,icons(W,icons(V,i[])))), o[])) .
     eq Multi(ocons(icons(X,icons(Y,i[])), ocons(icons(Z,i[]), o[]))) = icons(Y, icons(Z, i[])) .
     eq Multi(ocons(icons(X,icons(Y,i[])), ocons(icons(Z,icons(V,i[])), o[]))) = icons(Y, icons(Z, i[])) .

     eq Multi(ocons(icons(X,i[]), ocons(icons(Y,i[]), ocons(icons(Z,i[]), o[])))) = icons(X, icons(Y, icons(Z,i[]))) .
endfm



fmod DEL-ODDS is
    sorts MyNat MyList MyBool InVec .

    op [] : -> MyList [ctor] .
    op cons : MyNat MyList -> MyList [ctor] .
    op 0 : -> MyNat [ctor] .
    op s : MyNat -> MyNat [ctor] .
    op f : -> MyBool [ctor] .
    op t : -> MyBool [ctor] .

    op DelOdds : MyList -> MyList [metadata "induce"] .
    op Odd : MyNat -> MyBool [metadata "pred nomatch"] .
    op in : MyList -> InVec [ctor] .
    op in : MyNat -> InVec [ctor] .

    vars X Y : MyList .

    eq DelOdds([]) = [] .

    eq DelOdds(cons(0,[])) = cons(0,[]) .
    eq DelOdds(cons(s(0),[])) = [] .
    eq DelOdds(cons(s(s(0)),[])) = cons(s(s(0)),[]) .
    eq DelOdds(cons(s(s(s(0))),[])) = [] .

    eq DelOdds(cons(0,cons(0,[]))) = cons(0,cons(0,[])) .
    eq DelOdds(cons(s(0),cons(0,[]))) = cons(0,[]) .
    eq DelOdds(cons(0,cons(s(0),[]))) = cons(0,[]) .
    eq DelOdds(cons(s(0),cons(s(0),[]))) = [] .

    eq Odd(0) = f .
    eq Odd(s(0)) = t .
    eq Odd(s(s(0))) = f .
    eq Odd(s(s(s(0)))) = t .
endfm


fmod DEL-ODDS2 is
    sorts MyNat MyList MyBool InVec .

    op [] : -> MyList [ctor] .
    op cons : MyNat MyList -> MyList [ctor] .
    op If : MyBool MyList MyList -> MyList [ctor] .
    op Odd : MyNat -> MyBool [ctor] .

    op DelOdds : MyList -> MyList [metadata "induce"] .

    op in : MyList -> InVec [ctor] .

    vars X Y : MyNat .

    eq DelOdds([]) = [] .

    eq DelOdds(cons(X,[])) = If(Odd(X), [], cons(X,[])) .

    eq DelOdds(cons(X,cons(Y,[]))) = If(Odd(X), If(Odd(Y), [], cons(Y,[])), cons(X,If(Odd(Y), [], cons(Y,[])))) .
endfm



fmod DEL-ZEROS is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op DelZeros : MyList -> MyList [metadata "induce"] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y : MyNat .

	eq DelZeros([]) = [] .
	eq DelZeros(cons(0,[])) = [] .
	eq DelZeros(cons(s(X),[])) = cons(s(X),[]) .
	eq DelZeros(cons(0,cons(0,[]))) = [] .
	eq DelZeros(cons(0,cons(s(X),[]))) = cons(s(X),[]) .
	eq DelZeros(cons(s(X),cons(0,[]))) = cons(s(X),[]) .
	eq DelZeros(cons(s(X),cons(s(Y),[]))) = cons(s(X),cons(s(Y),[])) .
endfm

fmod ADD is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Add : MyNat MyNat -> MyNat [metadata "induce"] .

	*** input encapsulation
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .

	eq Add(0,0) = 0 .
	eq Add(s(0),0) = s(0) .
	eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .
	eq Add(s(s(0)),s(0)) = s(s(s(0))) .
	eq Add(0,s(s(0))) = s(s(0)) .
	eq Add(s(0),s(s(0))) = s(s(s(0))) .
	eq Add(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
endfm

fmod FACTORIAL is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata ""] .
	op Add : MyNat MyNat -> MyNat [metadata ""] .
	op Fac : MyNat -> MyNat [metadata "induce"] .

	op in : MyNat -> InVec [ctor] .
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .

	***eq Add(0,0) = 0 .
	***eq Add(s(0),0) = s(0) .
	***eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .
	eq Add(s(s(0)),s(0)) = s(s(s(0))) .
	eq Add(0,s(s(0))) = s(s(0)) .
	eq Add(s(0),s(s(0))) = s(s(s(0))) .
	eq Add(s(s(0)),s(s(0))) = s(s(s(s(0)))) .

	***eq Mult(0,s(0)) = 0 .
	eq Mult(0,X) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(X,0) = 0 .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(0,s(X)) = 0 .
	eq Mult(s(0),s(s(0))) = s(s(0)) .
	eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
	***eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(s(0),s(s(0))) = s(s(0)) .

	eq Fac(0) = s(0) .
	eq Fac(s(0)) = s(0) .
	eq Fac(s(s(0))) = s(s(0)) .
	eq Fac(s(s(s(0)))) = s(s(s(s(s(s(0)))))) .
endfm


fmod TAILFACTORIAL is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata ""] .
	op Add : MyNat MyNat -> MyNat [metadata ""] .
	op Fac : MyNat MyNat -> MyNat [metadata "induce"] .

	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .

	***eq Add(0,0) = 0 .
	***eq Add(s(0),0) = s(0) .
	***eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .
	eq Add(s(s(0)),s(0)) = s(s(s(0))) .
	eq Add(0,s(s(0))) = s(s(0)) .
	eq Add(s(0),s(s(0))) = s(s(s(0))) .
	eq Add(s(s(0)),s(s(0))) = s(s(s(s(0)))) .

	***eq Mult(0,s(0)) = 0 .
	eq Mult(0,X) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(X,0) = 0 .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(0,s(X)) = 0 .
	eq Mult(s(0),s(s(0))) = s(s(0)) .
	eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
	***eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(s(0),s(s(0))) = s(s(0)) .

	eq Fac(0, s(0)) = s(0) .
	eq Fac(s(0), s(0)) = s(0) .
	eq Fac(0, s(s(0))) = s(s(0)) .
	eq Fac(s(0), s(s(0))) = s(s(0)) .
	eq Fac(s(s(0)), s(0)) = s(s(0)) .
	eq Fac(0, s(s(s(s(s(s(0))))))) = s(s(s(s(s(s(0)))))) .
	eq Fac(s(0), s(s(s(s(s(s(0))))))) = s(s(s(s(s(s(0)))))) .
	eq Fac(s(s(0)), s(s(s(0)))) = s(s(s(s(s(s(0)))))) .
	eq Fac(s(s(s(0))), s(0)) = s(s(s(s(s(s(0)))))) .
endfm

fmod MULT is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata "induce"] .
	op Add : MyNat MyNat -> MyNat [metadata ""] .

	*** input encapsulation
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .

	***eq Add(0,0) = 0 .
	***eq Add(s(0),0) = s(0) .
	***eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .
	eq Add(s(s(0)),s(0)) = s(s(s(0))) .
	eq Add(0,s(s(0))) = s(s(0)) .
	eq Add(s(0),s(s(0))) = s(s(s(0))) .
	eq Add(s(s(0)),s(s(0))) = s(s(s(s(0)))) .

	***eq Mult(0,s(0)) = 0 .
	eq Mult(0,X) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(X,0) = 0 .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(0,s(X)) = 0 .
	eq Mult(s(0),s(s(0))) = s(s(0)) .
	eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
	***eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(s(0),s(s(0))) = s(s(0)) .
endfm


fmod MULT2 is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata "induce"] .
	op Add : MyNat MyNat -> MyNat [metadata ""] .

	*** input encapsulation
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .
	eq Add(0,0) = 0 .
	eq Add(s(0),0) = s(0) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .

	***eq Mult(0,X) = 0 .
	eq Mult(0,0) = 0 .
	eq Mult(0,s(0)) = 0 .
	eq Mult(0,s(s(0))) = 0 .
	eq Mult(s(0),0) = 0 .
	***eq Mult(s(X),0) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	eq Mult(s(0),s(s(0))) = s(s(0)) .
	eq Mult(s(s(0)),0) = 0 .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
endfm

fmod MULT3 is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata "induce"] .
	op Add : MyNat MyNat -> MyNat [metadata ""] .

	*** input encapsulation
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .

	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .
	eq Add(0,0) = 0 .
	eq Add(s(0),0) = s(0) .
	eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .


	***eq Mult(0,X) = 0 .
	eq Mult(0,0) = 0 .
	eq Mult(0,s(0)) = 0 .
	***eq Mult(0,s(s(0))) = 0 .
	eq Mult(s(0),0) = 0 .
	***eq Mult(s(X),0) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	***eq Mult(s(0),s(s(0))) = s(s(0)) .
	***eq Mult(s(s(0)),0) = 0 .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
endfm


fmod P-SM is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op P1 : MyList -> MyList [metadata "induce"] .
	op Sm : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .



	eq Sm(0,0) = false .
	eq Sm(0,s(0)) = true .
	eq Sm(0,s(s(0))) = true .
	eq Sm(0,s(s(s(0)))) = true .
	eq Sm(s(0),0) = false .
	eq Sm(s(0),s(0)) = false .
	eq Sm(s(0),s(s(0))) = true .
	eq Sm(s(0),s(s(s(0)))) = true .
	eq Sm(s(s(0)),0) = false .
	eq Sm(s(s(0)),s(0)) = false .
	eq Sm(s(s(0)),s(s(0))) = false .
	eq Sm(s(s(0)),s(s(s(0)))) = true .
	eq Sm(s(s(s(0))),0) = false .
	eq Sm(s(s(s(0))),s(0)) = false .
	eq Sm(s(s(s(0))),s(s(0))) = false .
	eq Sm(s(s(s(0))),s(s(s(0)))) = false .



	eq P1(cons(0,[])) = [] .
	eq P1(cons(s(0),[])) = [] .
	eq P1(cons(s(s(0)),[])) = [] .

	eq P1(cons(0,cons(s(0),[]))) = [] .
	eq P1(cons(s(0),cons(0,[]))) = cons(0,[]) .
	eq P1(cons(s(0),cons(s(s(0)),[]))) = [] .
	***eq P1(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),[]) .
	***eq P1(cons(0,cons(s(s(0)),[]))) = [] .
	eq P1(cons(s(s(0)),cons(0,[]))) = cons(0,[]) .

	eq P1(cons(s(0),cons(s(s(s(0))),cons(0,cons(s(s(0)),[]))))) = cons(0,[]) .
	eq P1(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,[]) .
	eq P1(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(s(0),cons(0,[])) .
endfm


fmod P-GR is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op P2 : MyList -> MyList [metadata "induce"] .
	op Sm : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .




	eq Sm(0,0) = false .
	eq Sm(0,s(0)) = true .
	eq Sm(0,s(s(0))) = true .
	eq Sm(0,s(s(s(0)))) = true .
	eq Sm(s(0),0) = false .
	eq Sm(s(0),s(0)) = false .
	eq Sm(s(0),s(s(0))) = true .
	eq Sm(s(0),s(s(s(0)))) = true .
	eq Sm(s(s(0)),0) = false .
	eq Sm(s(s(0)),s(0)) = false .
	eq Sm(s(s(0)),s(s(0))) = false .
	eq Sm(s(s(0)),s(s(s(0)))) = true .
	eq Sm(s(s(s(0))),0) = false .
	eq Sm(s(s(s(0))),s(0)) = false .
	eq Sm(s(s(s(0))),s(s(0))) = false .
	eq Sm(s(s(s(0))),s(s(s(0)))) = false .



	eq P2(cons(0,[])) = [] .
	eq P2(cons(s(0),[])) = [] .
	eq P2(cons(s(s(0)),[])) = [] .

	eq P2(cons(0,cons(s(0),[]))) = cons(s(0),[]) .
	eq P2(cons(s(0),cons(0,[]))) = [] .
	eq P2(cons(s(0),cons(s(s(0)),[]))) = cons(s(s(0)),[]) .
	***eq P1(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),[]) .
	***eq P1(cons(0,cons(s(s(0)),[]))) = [] .
	eq P2(cons(s(s(0)),cons(0,[]))) = [] .

	eq P2(cons(s(0),cons(s(s(s(0))),cons(0,cons(s(s(0)),[]))))) = cons(s(s(s(0))),cons(s(s(0)),[])) .
	eq P2(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(s(s(0)),[]) .
	eq P2(cons(s(s(0)),cons(s(0),cons(0,[])))) = [] .
endfm




fmod QSORT-BK is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Sort : MyList -> MyList [metadata "induce"] .
	op App : MyList MyList -> MyList [metadata ""] .
	op P1 : MyList -> MyList [metadata ""] .
	op P2 : MyList -> MyList [metadata ""] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyList MyList -> InVec [ctor] .


	eq Sort([]) = [] .

	eq Sort(cons(0,[])) = cons(0,[]) .
	eq Sort(cons(s(0),[])) = cons(s(0),[]) .
	***eq Sort(cons(s(s(0)),[])) = cons(s(s(0)),[]) .

	eq Sort(cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	***eq Sort(cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(0),cons(0,[]))) = cons(0,cons(s(0),[])) .
	***eq Sort(cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	***eq Sort(cons(s(s(0)),cons(0,[]))) = cons(0,cons(s(s(0)),[])) .
	***eq Sort(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),cons(s(s(0)),[])) .

	***eq Sort(cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(0,cons(s(s(0)),cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(0),cons(s(s(0)),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(s(0)),cons(0,cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .

	eq P1(cons(0,[])) = [] .
	eq P1(cons(s(0),[])) = [] .
	eq P1(cons(0,cons(s(0),[]))) = [] .
	eq P1(cons(s(0),cons(0,[]))) = cons(0,[]) .
	eq P1(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(s(0),cons(0,[])) .

	eq P2(cons(0,[])) = [] .
	eq P2(cons(s(0),[])) = [] .
	eq P2(cons(0,cons(s(0),[]))) = cons(s(0),[]) .
	eq P2(cons(s(0),cons(0,[]))) = [] .
	eq P2(cons(s(s(0)),cons(s(0),cons(0,[])))) = [] .

	***eq App([],[]) = [] .
	eq App([],cons(0,[])) = cons(0,[]) .
	eq App([],cons(s(0),[])) = cons(s(0),[]) .
	eq App([],cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq App(cons(0,[]),cons(s(0),[])) = cons(0,cons(s(0),[])) .
	eq App(cons(0,cons(s(0),[])),cons(s(s(0)),[])) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm


fmod ACKERMANN is
	sorts MyNat InVec .

	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Ack : MyNat MyNat -> MyNat [metadata "induce"] .
	op in : MyNat MyNat -> InVec [ctor] .

	eq Ack(0,0) = s(0) .
	eq Ack(0,s(0)) = s(s(0)) .
	eq Ack(0,s(s(0))) = s(s(s(0))) .
	eq Ack(0,s(s(s(0)))) = s(s(s(s(0)))) .
	eq Ack(0,s(s(s(s(0))))) = s(s(s(s(s(0))))) .

	eq Ack(s(0),0) = s(s(0)) .
	eq Ack(s(0),s(0)) = s(s(s(0))) .
	eq Ack(s(0),s(s(0))) = s(s(s(s(0)))) .
	eq Ack(s(0),s(s(s(0)))) = s(s(s(s(s(0))))) .
	***eq Ack(s(0),s(s(s(s(0))))) = s(s(s(s(s(s(0)))))) .

	eq Ack(s(s(0)),0) = s(s(s(0))) .
	eq Ack(s(s(0)),s(0)) = s(s(s(s(s(0))))) .
	eq Ack(s(s(0)),s(s(0))) = s(s(s(s(s(s(s(0))))))) .
	eq Ack(s(s(0)),s(s(s(0)))) = s(s(s(s(s(s(s(s(s(0))))))))) .
	***eq Ack(s(s(0)),s(s(s(s(0))))) = s(s(s(s(s(s(s(s(s(s(s(0))))))))))) .

	***eq Ack(s(s(s(0))),0) = s(s(s(s(s(0))))) .
	***eq Ack(s(s(s(0))),s(0)) = s(s(s(s(s(s(s(s(s(s(s(s(s(0))))))))))))) .

endfm


fmod QSORT is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Sort : MyList -> MyList [metadata "induce"] .
	op App : MyList MyList -> MyList [metadata ""] .
	op Sm : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyList MyList -> InVec [ctor] .


	eq Sm(0,0) = false .
	eq Sm(0,s(0)) = true .
	eq Sm(0,s(s(0))) = true .
	eq Sm(0,s(s(s(0)))) = true .
	eq Sm(s(0),0) = false .
	eq Sm(s(0),s(0)) = false .
	eq Sm(s(0),s(s(0))) = true .
	eq Sm(s(0),s(s(s(0)))) = true .
	eq Sm(s(s(0)),0) = false .
	eq Sm(s(s(0)),s(0)) = false .
	eq Sm(s(s(0)),s(s(0))) = false .
	eq Sm(s(s(0)),s(s(s(0)))) = true .
	eq Sm(s(s(s(0))),0) = false .
	eq Sm(s(s(s(0))),s(0)) = false .
	eq Sm(s(s(s(0))),s(s(0))) = false .
	eq Sm(s(s(s(0))),s(s(s(0)))) = false .



	eq Sort([]) = [] .

	eq Sort(cons(0,[])) = cons(0,[]) .
	eq Sort(cons(s(0),[])) = cons(s(0),[]) .
	eq Sort(cons(s(s(0)),[])) = cons(s(s(0)),[]) .

	eq Sort(cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(0),cons(0,[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(0,[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),cons(s(s(0)),[])) .

	***eq Sort(cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(0,cons(s(s(0)),cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(0),cons(s(s(0)),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(s(0)),cons(0,cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq Sort(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .

	***eq App([],[]) = [] .
	eq App([],cons(0,[])) = cons(0,[]) .
	eq App([],cons(s(0),[])) = cons(s(0),[]) .
	eq App([],cons(s(s(0)),[])) = cons(s(s(0)),[]) .

	eq App([],cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq App([],cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq App([],cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	eq App([],cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq App(cons(0,[]),cons(s(0),[])) = cons(0,cons(s(0),[])) .
	eq App(cons(0,[]),cons(s(s(0)),[])) = cons(0,cons(s(s(0)),[])) .
	eq App(cons(s(0),[]),cons(s(s(0)),[])) = cons(s(0),cons(s(s(0)),[])) .
	eq App(cons(0,[]),cons(s(0),cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	***eq App(cons(0,cons(s(0),[])),cons(s(s(0)),[])) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm




fmod MIN is
	sorts MyNat MyList InVec .

	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Min : MyList -> MyNat [metadata "induce"] .
	op SmEq : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	op in : MyList -> InVec [ctor] .

	eq SmEq(0,0) = true .
	eq SmEq(0,s(0)) = true .
	eq SmEq(0,s(s(0))) = true .
	eq SmEq(0,s(s(s(0)))) = true .
	eq SmEq(s(0),0) = false .
	eq SmEq(s(0),s(0)) = true .
	eq SmEq(s(0),s(s(0))) = true .
	eq SmEq(s(0),s(s(s(0)))) = true .
	eq SmEq(s(s(0)),0) = false .
	eq SmEq(s(s(0)),s(0)) = false .
	eq SmEq(s(s(0)),s(s(0))) = true .
	eq SmEq(s(s(0)),s(s(s(0)))) = true .
	eq SmEq(s(s(s(0))),0) = false .
	eq SmEq(s(s(s(0))),s(0)) = false .
	eq SmEq(s(s(s(0))),s(s(0))) = false .
	eq SmEq(s(s(s(0))),s(s(s(0)))) = true .





	***var X : MyNat .

	eq Min(cons(0,[])) = 0 .
	eq Min(cons(s(0),[])) = s(0) .
	***eq Min(cons(X,[])) = X .

	***eq Min(cons(0,cons(0,[]))) = 0 .
	eq Min(cons(0,cons(s(0),[]))) = 0 .
	eq Min(cons(s(0),cons(0,[]))) = 0 .
	***eq Min(cons(s(0),cons(s(0),[]))) = s(0) .
	***eq Min(cons(0,cons(X,[]))) = 0 .
	eq Min(cons(s(0),cons(s(s(0)),[]))) = s(0) .
	eq Min(cons(s(s(0)),cons(s(0),[]))) = s(0) .
	eq Min(cons(s(s(s(0))),cons(0,[]))) = 0 .
	***eq Min(cons(0,cons(s(s(0)),[]))) = 0 .
	***eq Min(cons(s(s(0)),cons(0,[]))) = 0 .

	eq Min(cons(s(0),cons(s(s(s(0))),cons(0,[])))) = 0 .
	eq Min(cons(s(s(s(0))),cons(s(0),cons(0,[])))) = 0 .
endfm


fmod BUT-MIN is
	sorts MyNat MyList InVec .

	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op ButMin : MyList -> MyList [metadata "induce"] .
	op SmEq : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	op in : MyList -> InVec [ctor] .

	eq SmEq(0,0) = true .
	eq SmEq(0,s(0)) = true .
	eq SmEq(0,s(s(0))) = true .
	eq SmEq(0,s(s(s(0)))) = true .
	eq SmEq(s(0),0) = false .
	eq SmEq(s(0),s(0)) = true .
	eq SmEq(s(0),s(s(0))) = true .
	eq SmEq(s(0),s(s(s(0)))) = true .
	eq SmEq(s(s(0)),0) = false .
	eq SmEq(s(s(0)),s(0)) = false .
	eq SmEq(s(s(0)),s(s(0))) = true .
	eq SmEq(s(s(0)),s(s(s(0)))) = true .
	eq SmEq(s(s(s(0))),0) = false .
	eq SmEq(s(s(s(0))),s(0)) = false .
	eq SmEq(s(s(s(0))),s(s(0))) = false .
	eq SmEq(s(s(s(0))),s(s(s(0)))) = true .

	eq ButMin(cons(0,[])) = [] .
	eq ButMin(cons(s(0),[])) = [] .

	eq ButMin(cons(0,cons(s(0),[]))) = cons(s(0),[]) .
	eq ButMin(cons(s(0),cons(0,[]))) = cons(s(0),[]) .
	***eq Min(cons(s(0),cons(s(0),[]))) = s(0) .
	***eq Min(cons(0,cons(X,[]))) = 0 .
	eq ButMin(cons(s(0),cons(s(s(0)),[]))) = cons(s(s(0)),[]) .
	eq ButMin(cons(s(s(0)),cons(s(0),[]))) = cons(s(s(0)),[]) .
	eq ButMin(cons(s(s(s(0))),cons(0,[]))) = cons(s(s(s(0))),[]) .
	***eq Min(cons(0,cons(s(s(0)),[]))) = 0 .
	***eq Min(cons(s(s(0)),cons(0,[]))) = 0 .

	eq ButMin(cons(s(0),cons(s(s(s(0))),cons(0,[])))) = cons(s(0),cons(s(s(s(0))),[])) .
	eq ButMin(cons(s(s(s(0))),cons(s(0),cons(0,[])))) = cons(s(s(s(0))),cons(s(0),[])) .

endfm





fmod INSERT is
	sorts MyNat MyList InVec .

	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Insert : MyNat MyList -> MyList [metadata "induce"] .
	op SmEq : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	op in : MyNat MyList -> InVec [ctor] .

	eq SmEq(0,s(0)) = true .
	eq SmEq(s(0),0) = false .
	eq SmEq(0,s(s(0))) = true .
	eq SmEq(s(s(0)),0) = false .
	eq SmEq(s(0),s(s(0))) = true .
	eq SmEq(s(s(0)),s(0)) = false .
	eq SmEq(0,0) = true .
	eq SmEq(s(0),s(0)) = true .
	eq SmEq(s(s(0)),s(s(0))) = true .

	eq Insert(0,[]) = cons(0,[]) .
	eq Insert(s(0),[]) = cons(s(0),[]) .
	eq Insert(s(s(0)),[]) = cons(s(s(0)),[]) .

	eq Insert(0,cons(s(0),[])) = cons(0,cons(s(0),[])) .
	eq Insert(0,cons(s(s(0)),[])) = cons(0,cons(s(s(0)),[])) .
	eq Insert(s(0),cons(0,[])) = cons(0,cons(s(0),[])) .
	eq Insert(s(0),cons(s(s(0)),[])) = cons(s(0),cons(s(s(0)),[])) .
	eq Insert(s(s(0)),cons(0,[])) = cons(0,cons(s(s(0)),[])) .
	eq Insert(s(s(0)),cons(s(0),[])) = cons(s(0),cons(s(s(0)),[])) .

	***eq Insert(0,cons(s(0),cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Insert(s(s(0)),cons(0,cons(s(0),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm


fmod DEL-SM is
	sorts MyNat MyList InVec .

	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Del : MyNat MyList -> MyList [metadata "induce"] .
	op Sm : MyNat MyNat -> Bool [metadata "pred nomatch"] .
	op in : MyNat MyList -> InVec [ctor] .

	eq Sm(0,s(0)) = true .
	eq Sm(s(0),0) = false .
	eq Sm(0,s(s(0))) = true .
	eq Sm(s(s(0)),0) = false .
	eq Sm(s(0),s(s(0))) = true .
	eq Sm(s(s(0)),s(0)) = false .
	eq Sm(0,0) = false .
	eq Sm(s(0),s(0)) = false .
	eq Sm(s(s(0)),s(s(0))) = false .

	eq Del(0,[]) = [] .
	eq Del(s(0),[]) = [] .

	eq Del(0,cons(0,[])) = cons(0,[]) .
	eq Del(0,cons(s(0),[])) = cons(s(0),[]) .
	eq Del(s(0),cons(0,[])) = [] .
	eq Del(s(0),cons(s(0),[])) = cons(s(0),[]) .

	eq Del(0,cons(0,cons(0,[]))) = cons(0,cons(0,[])) .
	eq Del(0,cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq Del(0,cons(s(0),cons(0,[]))) = cons(s(0),cons(0,[])) .
	eq Del(0,cons(s(0),cons(s(0),[]))) = cons(s(0),cons(s(0),[])) .

	eq Del(s(0),cons(0,cons(0,[]))) = [] .
	eq Del(s(0),cons(0,cons(s(0),[]))) = cons(s(0),[]) .
	eq Del(s(0),cons(s(0),cons(0,[]))) = cons(s(0),[]) .
	eq Del(s(0),cons(s(0),cons(s(0),[]))) = cons(s(0),cons(s(0),[])) .
endfm



fmod MEMBER is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	ops a b c : -> MyItem [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Member : MyItem MyList -> MyList [metadata "induce"] .

	*** input encapsulation
	op in : MyItem MyList -> InVec [ctor] .

	***vars X Y : MyList .

	eq Member(a,[]) = [] .
	eq Member(b,[]) = [] .
	eq Member(a,cons(a,[])) = cons(a,[]) .
	eq Member(a,cons(b,[])) = [] .
	eq Member(b,cons(a,[])) = [] .
	eq Member(b,cons(b,[])) = cons(b,[]) .
	eq Member(a,cons(a,cons(b,[]))) = cons(a,cons(b,[])) .
	eq Member(a,cons(b,cons(a,[]))) = cons(a,[]) .
	eq Member(b,cons(a,cons(b,[]))) = cons(b,[]) .
	eq Member(b,cons(b,cons(a,[]))) = cons(b,cons(a,[])) .
	eq Member(a,cons(c,cons(a,cons(b,[])))) = cons(a,cons(b,[])) .
	eq Member(a,cons(a,cons(b,cons(c,[])))) = cons(a,cons(b,cons(c,[]))) .
	eq Member(a,cons(c,cons(b,cons(a,[])))) = cons(a,[]) .
endfm


fmod DELETE is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	ops a b : -> MyItem [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Delete : MyItem MyList -> MyList [metadata "induce"] .

	*** input encapsulation
	op in : MyItem MyList -> InVec [ctor] .

	eq Delete(a,[]) = [] .
	eq Delete(b,[]) = [] .
	eq Delete(a,cons(a,[])) = [] .
	eq Delete(a,cons(b,[])) = cons(b,[]) .
	eq Delete(b,cons(a,[])) = cons(a,[]) .
	eq Delete(b,cons(b,[])) = [] .
	eq Delete(a,cons(a,cons(a,[]))) = [] .
	eq Delete(b,cons(b,cons(b,[]))) = [] .
	eq Delete(a,cons(a,cons(b,[]))) = cons(b,[]) .
	eq Delete(b,cons(a,cons(b,[]))) = cons(a,[]) .
	eq Delete(a,cons(b,cons(b,[]))) = cons(b,cons(b,[])) .
endfm


fmod REPLACE is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .
	ops a b c : -> MyItem [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Repl : MyList -> MyList [metadata "induce"] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	eq Repl([]) = [] .
	eq Repl(cons(a,[])) = cons(c,[]) .
	eq Repl(cons(b,[])) = cons(b,[]) .
	eq Repl(cons(a,cons(a,[]))) = cons(c,cons(c,[])) .
	eq Repl(cons(a,cons(b,[]))) = cons(c,cons(b,[])) .
	eq Repl(cons(b,cons(a,[]))) = cons(b,cons(c,[])) .
	eq Repl(cons(b,cons(b,[]))) = cons(b,cons(b,[])) .
endfm


fmod REV-BK is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Rev : MyList -> MyList [metadata "induce"] .
	op Snoc : MyList MyItem -> MyList [metadata ""] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyList MyItem -> InVec [ctor] .

	vars X Y Z : MyItem .

	*** examples
	eq Snoc([],Z) = cons(Z,[]) .
	eq Snoc(cons(X,[]),Z) = cons(X,cons(Z,[])) .
	eq Snoc(cons(X,cons(Y,[])),Z) = cons(X,cons(Y,cons(Z,[]))) .

	eq Rev([]) = [] .
	eq Rev(cons(X,[])) =  cons(X,[]) .
	eq Rev(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq Rev(cons(X,cons(Y,cons(Z,[])))) = cons(Z,cons(Y,cons(X,[]))) .
endfm


fmod REV-BK2 is
	sorts MyItem MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	*** defined function names (to be induced, preds, bk)
	op Rev : MyList -> MyList [metadata "induce"] .
	***op LastBK : MyList -> MyItem [metadata ""] .
	***op InitBK : MyList -> MyList [metadata ""] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	vars X Y Z V W Q : MyItem .

	*** examples
	eq Rev([]) = [] .
	eq Rev(cons(X,[])) = cons(X,[]) .
	eq Rev(cons(X,cons(Y,[]))) = cons(Y,cons(X,[])) .
	eq Rev(cons(X,cons(Y,cons(Z,[])))) = cons(Z,cons(Y,cons(X,[]))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,[]))))) = cons(V,cons(Z,cons(Y,cons(X,[])))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,[])))))) = cons(W,cons(V,cons(Z,cons(Y,cons(X,[]))))) .
	***eq Rev(cons(X,cons(Y,cons(Z,cons(V,cons(W,cons(Q,[]))))))) = cons(Q,cons(W,cons(V,cons(Z,cons(Y,cons(X,[])))))) .

	***eq LastBK(cons(X,[])) = X .
	***eq LastBK(cons(X,cons(Y,[]))) = Y .
	***eq LastBK(cons(X,cons(Y,cons(Z,[])))) = Z .

	***eq InitBK(cons(X,[])) = [] .
	***eq InitBK(cons(X,cons(Y,[]))) = cons(X,[]) .
	***eq InitBK(cons(X,cons(Y,cons(Z,[])))) =  cons(X,cons(Y,[])) .
endfm




fmod MATCHTEST is
	sorts MyItem MyList InVec .
	op [] : -> MyList [ctor] .
	op cons : MyItem MyList -> MyList [ctor] .

	op Ind : MyList -> MyList [metadata "induce"] .
	op BK : MyList -> MyList [metadata ""] .
	op in : MyList -> InVec [ctor] .

	vars X Y : MyItem .

	eq Ind(cons(X,[])) = [] .
	eq BK(cons(X,[])) = [] .
	eq Ind(cons(X,cons(Y,[]))) = cons(X,[]) .
	eq BK(cons(X,cons(Y,[]))) = cons(X,[]) .
endfm

fmod MITCHELL-1 is
	sorts MyVal MyList MyBool InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyVal MyList -> MyList [ctor] .
	ops true false : -> MyBool [ctor] .

	ops sunny rainy warm cold normal high
		strong cool same change : -> MyVal [ctor] .

	op EnjoySport : MyList -> MyBool [metadata "induce"] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	eq EnjoySport(cons(sunny,cons(warm,cons(normal,
		cons(strong,cons(warm,cons(same,[]))))))) = true .
	eq EnjoySport(cons(sunny,cons(warm,cons(high,
		cons(strong,cons(warm,cons(same,[]))))))) = true .
	eq EnjoySport(cons(rainy,cons(cold,cons(high,
		cons(strong,cons(warm,cons(change,[]))))))) = false .
	eq EnjoySport(cons(sunny,cons(warm,cons(high,
		cons(strong,cons(cool,cons(change,[]))))))) = true .
endfm

fmod MITCHELL-2 is
	sorts MyVal MyList MyBool InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyVal MyList -> MyList [ctor] .

	ops true false : -> MyBool [ctor] .

	ops sunny overcast rain hot mild cool
		high normal weak strong : -> MyVal [ctor] .

	op PlayTennis : MyList -> MyBool [metadata "induce"] .

	*** input encapsulation
	op in : MyList -> InVec [ctor] .

	eq PlayTennis(cons(sunny,cons(hot,cons(high,cons(weak,[]))))) = false .
	eq PlayTennis(cons(sunny,cons(hot,cons(high,cons(strong,[]))))) = false .
	eq PlayTennis(cons(overcast,cons(hot,cons(high,cons(weak,[]))))) = true .
	eq PlayTennis(cons(rain,cons(mild,cons(high,cons(weak,[]))))) = true .
	eq PlayTennis(cons(rain,cons(cool,cons(normal,cons(weak,[]))))) = true .
	eq PlayTennis(cons(rain,cons(cool,cons(normal,cons(strong,[]))))) = false .
	eq PlayTennis(cons(overcast,cons(cool,cons(normal,cons(strong,[]))))) = true .
	eq PlayTennis(cons(sunny,cons(mild,cons(high,cons(weak,[]))))) = false .
	eq PlayTennis(cons(sunny,cons(cool,cons(normal,cons(weak,[]))))) = true .
	eq PlayTennis(cons(rain,cons(mild,cons(normal,cons(weak,[]))))) = true .
	eq PlayTennis(cons(sunny,cons(mild,cons(normal,cons(strong,[]))))) = true .
	eq PlayTennis(cons(overcast,cons(mild,cons(high,cons(strong,[]))))) = true .
	eq PlayTennis(cons(overcast,cons(hot,cons(normal,cons(weak,[]))))) = true .
	eq PlayTennis(cons(rain,cons(mild,cons(high,cons(strong,[]))))) = false .
endfm
