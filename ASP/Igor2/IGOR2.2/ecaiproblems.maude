fmod WEAVE is
sorts MyItem MyList InVec . 
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .

op weave : MyList MyList -> MyList [metadata "induce"] .

op in : MyList MyList -> InVec [ctor] .

vars U V W X Y Z : MyItem .
var L : MyList .

eq weave([],[]) = [] .

eq weave(cons(X,[]),[]) = cons(X,[]) .
eq weave([],cons(X,[])) = cons(X,[]) .

eq weave(cons(X,[]),cons(Y,[])) = cons(X,cons(Y,[])) .

eq weave(cons(X,cons(Y,[])),cons(Z,[])) = cons(X,cons(Z,cons(Y,[]))) .
eq weave(cons(Z,[]),cons(X,cons(Y,[]))) = cons(Z,cons(X,cons(Y,[]))) .


eq weave([],cons(X,cons(Y,[]))) = cons(X,cons(Y,[])) .
eq weave(cons(X,cons(Y,[])),[]) = cons(X,cons(Y,[])) .

eq weave(cons(W,cons(X,[])),cons(Y,cons(Z,[]))) = cons(W,cons(Y,cons(X,cons(Z,[])))) .

endfm

fmod LAST is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op last : MyList -> MyItem [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq last(cons(Y,[])) = Y .
eq last(cons(Y,cons(X,[]))) = X .
eq last(cons(Y,cons(X,cons(Z,[])))) = Z .

endfm


fmod LASTS is 
sorts MyItem MyList MyLList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
op # : -> MyLList [ctor] .
op consl : MyList MyLList -> MyLList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op lasts : MyLList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyLList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq lasts(#) = [] .
eq lasts(consl(cons(Y,[]),#)) = cons(Y,[]) .
eq lasts(consl(cons(Y,cons(X,[])),#)) = cons(X,[]) .
eq lasts(consl(cons(Y,cons(X,cons(Z,[]))),#)) = cons(Z,[]) .
eq lasts(consl(cons(Y,[]),consl(cons(X,[]),#))) = cons(Y,cons(X,[])) .
eq lasts(consl(cons(X,[]),consl(cons(Y,cons(Z,[])),#))) = cons(X,cons(Z,[])) .
eq lasts(consl(cons(X,cons(V,[])),consl(cons(Y,cons(Z,[])),#))) = cons(V,cons(Z,[])) .
eq lasts(consl(cons(X,cons(V,[])),consl(cons(Z,[]),#))) = cons(V,cons(Z,[])) .
eq lasts(consl(cons(Z,[]),consl(cons(Y,cons(X,[])),consl(cons(V,[]),#)))) = cons(Z,cons(X,cons(V,[]))) .
eq lasts(consl(cons(Z,cons(X,[])),consl(cons(Y,cons(V,[])),consl(cons(W,[]),#)))) = cons(X,cons(V,cons(W,[]))) .
***eq lasts(consl(cons(Z,cons(X,[])),consl(cons(V,cons(Y,[])),consl(cons(W,cons(U,[])),#)))) = cons(X,cons(Y,cons(U,[]))) .

endfm
fmod MEM is 
sorts MyItem MyBool MyList InVec .
 
*** DT definitions (constructors)
op t : -> MyBool [ctor] .
op f : -> MyBool [ctor] .
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op mem : MyItem MyList -> MyBool [metadata "induce"] .
*** input encapsulation
op in : MyItem MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq mem(W,[]) = f .
eq mem(W,cons(Y,[])) = f .
eq mem(W,cons(Y,cons(Z,[]))) = f .
eq mem(Y,cons(X,cons(Y,cons(W,[])))) = t .

endfm

fmod MULTADD is
	sorts MyNat InVec .

	*** DT definitions (constructors)
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Mult : MyNat MyNat -> MyNat [metadata "induce"] .
	op Add : MyNat MyNat -> MyNat [metadata "induce"] .
	
	*** input encapsulation
	op in : MyNat MyNat -> InVec [ctor] .

	vars X Y : MyNat .
	
	***eq Add(0,X) = X .
	***eq Add(s(0),X) = s(X) .
	***eq Add(s(s(0)),X) = s(s(X)) .
	
	***eq Add(0,0) = 0 .
	***eq Add(s(0),0) = s(0) .
	***eq Add(s(s(0)),0) = s(s(0)) .
	eq Add(0,s(0)) = s(0) .
	eq Add(s(0),s(0)) = s(s(0)) .
	eq Add(s(s(0)),s(0)) = s(s(s(0))) .
	eq Add(0,s(s(0))) = s(s(0)) .
	eq Add(s(0),s(s(0))) = s(s(s(0))) .
	eq Add(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
	
	eq Mult(0,s(0)) = 0 .
	eq Mult(0,0) = 0 .
	eq Mult(s(0),s(0)) = s(0) .
	eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(X,0) = 0 .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(0,s(X)) = 0 .
	eq Mult(s(0),s(s(0))) = s(s(0)) .
	eq Mult(s(s(0)),s(s(0))) = s(s(s(s(0)))) .
	***eq Mult(s(s(0)),s(0)) = s(s(0)) .
	***eq Mult(0,s(s(0))) = 0 .
	***eq Mult(s(0),s(s(0))) = s(s(0)) .
endfm

fmod MULTFIRST is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op multfirst : MyList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq multfirst([]) = [] .
eq multfirst(cons(Y,[])) = cons(Y,[]) .
eq multfirst(cons(Y,cons(X,[]))) = cons(Y,cons(Y,[])) .
eq multfirst(cons(Y,cons(X,cons(Z,[])))) = cons(Y,cons(Y,cons(Y,[]))) .

endfm


fmod MULTLAST is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op multlast : MyList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq multlast([]) = [] .
eq multlast(cons(Y,[])) = cons(Y,[]) .
eq multlast(cons(Y,cons(X,[]))) = cons(X,cons(X,[])) .
eq multlast(cons(Y,cons(X,cons(Z,[])))) = cons(Z,cons(Z,cons(Z,[]))) .

endfm

fmod EVENODD is
	sorts MyNat MyBool InVec .
	
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .
	op t : -> MyBool [ctor] .
	op f : -> MyBool [ctor] .
	
	op Even : MyNat -> MyBool [metadata "induce"] .
	op Odd : MyNat -> MyBool [metadata "induce"] .
	op in : MyNat -> InVec [ctor] .
	
	eq Even(0) = t .
	eq Even(s(0)) = f .
	eq Even(s(s(0))) = t .
	
	eq Odd(0) = f .
	eq Odd(s(0)) = t .
	eq Odd(s(s(0))) = f .
	***eq Odd(s(s(s(0)))) = t .
endfm


fmod ODDSLIST is 
sorts MyNat MyBool MyList InVec .
 
*** DT definitions (constructors)
op t : -> MyBool [ctor] .
op f : -> MyBool [ctor] .
op 0 : -> MyNat [ctor] .
op s : MyNat -> MyNat [ctor] .
op [] : -> MyList [ctor] .
op cons : MyNat MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op oddslist : MyList -> MyBool [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars X Y Z : MyNat .

eq oddslist([]) = t .
eq oddslist(cons(s(0),[])) = t .
eq oddslist(cons(0,[])) = f .
eq oddslist(cons(s(s(0)),[])) = f .
eq oddslist(cons(s(s(s(0))),[])) = t .
eq oddslist(cons(0,cons(0,[]))) = f .
eq oddslist(cons(0,cons(s(0),[]))) = f .
eq oddslist(cons(0,cons(s(s(0)),[]))) = f .
eq oddslist(cons(0,cons(s(s(s(0))),[]))) = f .
eq oddslist(cons(s(0),cons(0,[]))) = f .
eq oddslist(cons(s(0),cons(s(0),[]))) = t .
eq oddslist(cons(s(0),cons(s(s(0)),[]))) = t .
eq oddslist(cons(s(0),cons(s(s(s(0))),[]))) = t .
eq oddslist(cons(s(s(0)),cons(0,[]))) = f .
eq oddslist(cons(s(s(0)),cons(s(0),[]))) = f .
eq oddslist(cons(s(s(0)),cons(s(s(0)),[]))) = f .
eq oddslist(cons(s(s(0)),cons(s(s(s(0))),[]))) = f .
eq oddslist(cons(s(s(s(0))),cons(0,[]))) = f .
eq oddslist(cons(s(s(s(0))),cons(s(0),[]))) = f .
eq oddslist(cons(s(s(s(0))),cons(s(s(0)),[]))) = f .
eq oddslist(cons(s(s(s(0))),cons(s(s(s(0))),[]))) = f .

endfm

fmod REVERSE is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op reverse : MyList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq reverse([]) = [] .
eq reverse(cons(Y,[])) = cons(Y,[]) .
eq reverse(cons(Y,cons(X,[]))) = cons(X,cons(Y,[])) .
eq reverse(cons(Y,cons(X,cons(Z,[])))) = cons(Z,cons(X,cons(Y,[]))) .

endfm

fmod SHIFTL is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op shiftl : MyList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq shiftl([]) = [] .
eq shiftl(cons(W,[])) = cons(W,[]) .
eq shiftl(cons(Y,cons(Z,[]))) = cons(Z,cons(Y,[])) .
eq shiftl(cons(X,cons(Z,cons(W,[])))) = cons(Z,cons(W,cons(X,[]))) .
eq shiftl(cons(X,cons(Z,cons(W,cons(Y,[]))))) = cons(Z,cons(W,cons(Y,cons(X,[])))) .

endfm

fmod SHIFTR is 
sorts MyItem MyList InVec .
 
*** DT definitions (constructors)
op [] : -> MyList [ctor] .
op cons : MyItem MyList -> MyList [ctor] .
 
*** defined function names (to be induced, preds, bk)
op shiftr : MyList -> MyList [metadata "induce"] .
*** input encapsulation
op in : MyList -> InVec [ctor] .
 
vars U V W X Y Z : MyItem .

eq shiftr([]) = [] .
eq shiftr(cons(W,[])) = cons(W,[]) .
eq shiftr(cons(Y,cons(Z,[]))) = cons(Z,cons(Y,[])) .
eq shiftr(cons(X,cons(Z,cons(W,[])))) = cons(W,cons(X,cons(Z,[]))) .
eq shiftr(cons(X,cons(Z,cons(W,cons(Y,[]))))) = cons(Y,cons(X,cons(Z,cons(W,[])))) .

endfm

fmod SORT2 is
	sorts MyNat MyList InVec .

	*** DT definitions (constructors)
	op [] : -> MyList [ctor] .
	op cons : MyNat MyList -> MyList [ctor] .
	op 0 : -> MyNat [ctor] .
	op s : MyNat -> MyNat [ctor] .

	op Sort : MyList -> MyList [metadata "induce"] .
	op Ins : MyNat MyList -> MyList [metadata ""] .
	*** input encapsulation
	op in : MyList -> InVec [ctor] .
	op in : MyNat MyList -> InVec [ctor] .
	
	eq Sort([]) = [] .
	
	vars X Y : MyNat .
	var L : MyList .
	
	***eq Sort(cons(0,[])) = cons(0,[]) .
	***eq Sort(cons(s(0),[])) = cons(s(0),[]) .
	***eq Sort(cons(s(s(0)),[])) = cons(s(s(0)),[]) .
	eq Sort(cons(X,[])) = cons(X,[]) .
	
	eq Sort(cons(0,cons(s(0),[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(0),cons(0,[]))) = cons(0,cons(s(0),[])) .
	eq Sort(cons(s(0),cons(s(s(0)),[]))) = cons(s(0),cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(0,[]))) = cons(0,cons(s(s(0)),[])) .
	eq Sort(cons(s(s(0)),cons(s(0),[]))) = cons(s(0),cons(s(s(0)),[])) .
	
	eq Sort(cons(0,cons(s(0),cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(0,cons(s(s(0)),cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(0),cons(0,cons(s(s(0)),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(0),cons(s(s(0)),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(0,cons(s(0),[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Sort(cons(s(s(0)),cons(s(0),cons(0,[])))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	
	
	
	***eq Ins(0,[]) = cons(0,[]) .
	***eq Ins(s(0),[]) = cons(s(0),[]) .
	***eq Ins(s(s(0)),[]) = cons(s(s(0)),[]) .
	eq Ins(X,[]) = cons(X,[]) .
	
	***eq Ins(0,cons(s(0),[])) = cons(0,cons(s(0),[])) .
	***eq Ins(0,cons(s(s(0)),[])) = cons(0,cons(s(s(0)),[])) .
	eq Ins(0,cons(Y,L)) = cons(0,cons(Y,L)) .
	eq Ins(s(0),cons(0,[])) = cons(0,cons(s(0),[])) .
	eq Ins(s(0),cons(s(s(0)),[])) = cons(s(0),cons(s(s(0)),[])) .
	eq Ins(s(s(0)),cons(0,[])) = cons(0,cons(s(s(0)),[])) .
	eq Ins(s(s(0)),cons(s(0),[])) = cons(s(0),cons(s(s(0)),[])) .
	
	***eq Ins(0,cons(s(0),cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(0),cons(0,cons(s(s(0)),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
	eq Ins(s(s(0)),cons(0,cons(s(0),[]))) = cons(0,cons(s(0),cons(s(s(0)),[]))) .
endfm
