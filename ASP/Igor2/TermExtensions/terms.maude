*** functions on terms
*** function symbols should not be overloaded

fmod TERM-EXTENSIONS is
	inc META-LEVEL . *** for sort Substitution?
	inc CONVERSION . *** for conversion between numbers and strings

	sort Coarities .	*** a set of pairs of function symbols with arity
			 			*** > 0 and their codomain types. Rationale: in the
			 			*** meta representation of terms only for variables
			 			*** and constants type information exists.
	sort Coarity .
	subsort Coarity < Coarities .
	
	op _:...->_ : Qid Type -> Coarity [ctor] .
	op none : -> Coarities [ctor] .
	op _;_ : Coarities Coarities -> Coarities 
			[ctor assoc comm id: none prec 120] .
	eq CoA:Coarity ; CoA:Coarity = CoA:Coarity .


	sort Variables .	*** set of variables
	subsort Variable < Variables .

	op noVars : -> Variables [ctor] .
	op _#_ : Variables Variables -> Variables [ctor assoc comm id: noVars] .
	eq V:Variable # V:Variable = V:Variable .
	
	
	var Ty : Type .
	var Sor : Sort .
	var Index : Nat .
	vars V W : Variable .
	var Vs : Variables .
	var C : Constant .
	vars T S : Term .
	var Root : Qid .
	vars TL Subterms Subterms1 Subterms2 TLInit TLRest : TermList .
	var CoAs : Coarities .
	var CoA : Coarity .
	var Sigma : Substitution? .
	
	*** gives the overall number of symbols in a term list
	op size : TermList -> Nat .
	eq size(empty) = 0 .
	eq size((C , TL)) = s size(TL) .
	eq size((V , TL)) = s size(TL) .
	eq size((Root [ Subterms ] , TL)) = s (size(Subterms) + size(TL)) .

	*** gives the number of terms in a term list
	op length : TermList -> Nat .
	eq length(empty) = 0 .
	eq length((T , TL)) = s length(TL) .
	
	*** true, if given term is a variable, false otherwise
	op isVar : Term -> Bool .
	eq isVar(V) = true .
	eq isVar(T) = false [owise] .
	
	*** creates a variable of given type, e.g., 'X3:Nat if
	*** given index is 3 and type is 'Nat
	op createVariable : Nat Type -> Variable .
	eq createVariable(Index, Sor) = 
		qid("X" + string(Index, 10) + ":" + string(Sor)) .
		
	op _in_ : Variable Variables -> Bool .
	eq V in (V # Vs) = true .
	eq V in Vs = false [owise] .
	
	*** op equalRoots : Term Term -> Bool .
	*** eq equalRoots(T, S) = root(T) == root(S) .
	
	*** op differentRoots : Term Term -> Bool .
	*** eq differentRoots(T, S) = root(T) =/= root(S) .
	
	op root : Term -> Qid .
	eq root(V) = V .
	eq root(C) = C .
	eq root(Root [ Subterms ]) = Root .
	
	*** returns type of the terms in TermList
	*** PRE: terms have equal types; 
	***      variable or constant or root occurs in Coarities
	op getType : TermList Coarities -> Qid .
	eq getType((V , TL), CoAs) = getType(V) .
	eq getType((C , TL), CoAs) = getType(C) .
	eq getType((Root [ Subterms ] , TL), (Root :...-> Ty ; CoAs)) = Ty .
	
	*** returns type (coarity) of a function symbol (non-constant)
	*** PRE: root occurs in Coarities
	op getType : Qid Coarities -> Qid .
	eq getType(Root, (Root :...-> Ty ; CoAs)) = Ty .
	
	*** resturns the total number of occurences of a variable 
	*** within a term list
	op #OccursOf_in_ : Variable TermList -> Nat .
	eq #OccursOf V in empty = 0 .
	eq #OccursOf V in (C , TL) = #OccursOf V in TL .
	eq #OccursOf V in (W , TL) = 
		(if V == W then 1 else 0 fi) + (#OccursOf V in TL) .
	eq #OccursOf V in (Root [ Subterms ] , TL) = 
		(#OccursOf V in Subterms) + (#OccursOf V in TL) .
		
	*** returns the set of variables of a term list	
	op var : TermList -> Variables .
	eq var(empty) = noVars .
	eq var((C , TL)) = var(TL) .
	eq var((V , TL)) = V # var(TL) .
	eq var((Root [ Subterms ] , TL)) = var(Subterms) # var(TL) .
	
	
	*** substitution
	op _(_) : Substitution Variable -> Term .
	eq (V <- T ; Sigma) ( V ) = T .
	eq Sigma ( V ) = V [owise] .
	
	*** applies substitution to terms
	op __ : TermList Substitution -> TermList .
	eq empty Sigma = empty .
	eq (V , TL) Sigma = Sigma ( V ) , TL Sigma .
	eq (C , TL) Sigma = C , TL Sigma .
	eq (Root [ Subterms ] , TL) Sigma = Root [ Subterms Sigma ] , TL Sigma .
		
	*** checks whether substitution (possibly noMatch) is a variable renaming
	op renaming? : Substitution? -> Bool .
	eq renaming?(noMatch) = false .
	eq renaming?((V <- C ; Sigma)) = false .
	eq renaming?((V <- Root [ Subterms ] ; Sigma)) = false .
	eq renaming?(Sigma) = true [owise] .
	
	
		
	*** Positions 
	sort Position .		*** a position in a term
	sort Positions .	*** position set
	subsorts NzNat < Position < Positions .
	op epsilon : -> Position [ctor]	.	*** root position
	op _._ : Position Position -> Position [ctor assoc id: epsilon] .
	op none : -> Positions [ctor] .
	op _;_ : Positions Positions -> Positions
			[ctor assoc comm id: none] .
	eq U:Position ; U:Position = U:Position .
	

	op getNthTerm : NzNat TermList -> Term .
	eq getNthTerm(1, (T , TL)) = T .
	eq getNthTerm(s Index, (T , TL)) = getNthTerm(Index, TL) [owise] .
	
	op _includes_ : TermList Term -> Bool .
	eq (TLInit , T , TLRest) includes T = true .
	eq TL includes T = false [owise] .

	sort TermListList .	*** inner term list at position n contains
				*** subterms at position n of original terms
	subsort TermList < TermListList .
	
	op blank : -> TermListList [ctor] .
	op _++_ : TermListList TermListList -> TermListList 
		[ctor assoc id: blank gather(e E) prec 125] .


	var Subterm : Term .
	var RemSubts : TermList .
	var SubtermsList : TermListList .


	*** PRE: non-empty term list; roots of given terms are all equal
	op createSubtermsList : TermList -> TermListList .
	eq createSubtermsList((C , TL)) = blank .
	eq createSubtermsList(Root [ Subterms ]) = 
		initSubtermsList(Subterms) .
	eq createSubtermsList((Root [ Subterms ] , TL)) =
		addSubterms(Subterms, createSubtermsList(TL)) .
		
	op initSubtermsList : TermList -> TermListList .
	eq initSubtermsList(empty) = blank .
	eq initSubtermsList((Subterm , RemSubts)) = 
		Subterm ++ initSubtermsList(RemSubts) .
		
	*** PRE: length(TermList) = length(TermListList)
	op addSubterms : TermList TermListList -> TermListList .
	eq addSubterms(empty, blank) = blank .
	eq addSubterms((Subterm , RemSubts) , (Subterms ++ SubtermsList)) = 
		(Subterm , Subterms) ++ 
			addSubterms(RemSubts, SubtermsList) .
	
endfm


	
	
	
