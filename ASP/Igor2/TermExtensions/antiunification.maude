*** Antiunification.

*** Main function is antiunify/2 which gets a TermList of terms to be
*** antiunified together with an initial variable index (a natural number).
*** It yields a result triple (of type AUResult): The first component is
*** the lgg of the terms in the given TermList; the second component is
*** a SubstitutionList corresponding to the given TermList (each term in the
*** given TermList is the result of applying the corresponding substitution in
*** the resulting SubstitutionList to the resulting lgg); the third component
*** is the updated variable index.
*** Variables in the lgg are named Xi where i is a natural number. The
*** indices i start with the given initial variable index and are then 
*** increased by 1 for each new variable. The resulting variable index is
*** incremented by 1 wrt the last introduced variable.

*** Note: function symbols of terms to antiunify should not be overloaded

fmod ANTIUNIFICATION is
	inc TERM-EXTENSIONS .
	
	sorts IndexedTerm IndexedTerms .	*** terms indexed by a key
	subsort IndexedTerm < IndexedTerms .
	
	op <_,_> : Nat Term -> IndexedTerm [ctor] .
	op none : -> IndexedTerms [ctor] .
	op _,_ : IndexedTerms IndexedTerms -> IndexedTerms 
				[ctor assoc comm id: none] .
	eq T:IndexedTerm , T:IndexedTerm = T:IndexedTerm .
	
	sort IndexedTermsList .		*** for subterms
	subsort IndexedTerms < IndexedTermsList .
	
	op empty : -> IndexedTermsList [ctor] .
	op _+_ :  IndexedTermsList IndexedTermsList -> IndexedTermsList
				[ctor assoc id: empty] .
	
	
	*** sort AUResult .	*** result of AU is a triple 
					*** (a term, an indexed substitution set, and a variable index)
	
	*** op <_,_,_> : Term IndexedSubstitutions Nat -> AUResult [ctor] .
		
	
	sort AUResult .	*** result triple of the antiunify-function
	sort AUSubResult .	*** result triple of the auxilliary auSubterms-function
	sort AssignmentData .	*** a triple of a variable, an indexed term set,
							*** and a position set;
							*** the terms are different subterms,
							*** the position set the set of positions
							*** in the lgg at which the variable occurs
	sort SubstitutionData .	*** set of AssignmentInfo (all variables)
	subsort AUResult < AUSubResult .
	subsort AssignmentData < SubstitutionData .
	
	op <_,_,_> : Term SubstitutionData Nat -> AUResult [ctor] .
	op <_,_,_> : TermList SubstitutionData Nat -> AUSubResult [ctor] .
	op <_;_;_> : Variable IndexedTerms Positions -> AssignmentData [ctor] .
	op empty : -> SubstitutionData [ctor] .
	op _,_ : SubstitutionData SubstitutionData -> SubstitutionData
		[ctor assoc comm id: empty] .
	eq AD:AssignmentData , AD:AssignmentData = AD:AssignmentData .
	
	sort InResult .
	
	op <_,_> : SubstitutionData SubstitutionData -> InResult [ctor] .
	
	vars ITs ITs1 ITs2 MatchedITs : IndexedTerms .
	vars InitIndex UpdIndex ResultIndex VarIndex Index : Nat .
	vars V Vfresh : Variable .
	var C : Constant . 
	vars T S LGG SubLGG Subterm T1 T2 : Term .
	vars TL SubLGGs Subterms RemSubts TL1 TL2 Subterms1 Subterms2 : TermList .
	vars SD UpdSD SDRest ResultSD : SubstitutionData .	
	vars AD AD1 AD2 : AssignmentData .
	var Coas : Coarities .
	var N : Nat .
	vars Key Key1 Key2 : Nat .
	var Positions : Positions .
	var Pos : Position .
	var Vars : Variables .
	var Root : Qid .
	var ISubts : IndexedTerms .
	var ISubtsList : IndexedTermsList .
	vars Unifyer Subunifyer : UnifyResult .
	var Repl : Term .
	var Sor : Sort .

		
	op antiunify : IndexedTerms Coarities SubstitutionData Nat Position 
				*** terms to antiunify, coas, initial subst data, initial
				*** var index, initial position
						-> AUResult .
						
	eq antiunify(ITs, Coas, SD, VarIndex, Pos) =
		$antiunify(ITs, Coas, SD, getVars(SD), VarIndex, Pos) .
		
	op getVars : SubstitutionData -> Variables .
	eq getVars(empty) = noVars .
	eq getVars((< V ; ITs ; Positions > , SDRest)) = V # getVars(SDRest) .

	op $antiunify : IndexedTerms Coarities SubstitutionData Variables Nat Position 
					-> AUResult .
		
	*** base case (given terms already exists as assignments 
	*** for a variable): introduce this variable here
	ceq $antiunify(ITs1, Coas, SD, Vars, VarIndex, Pos) = 
			< V , 
			  (< V ; MatchedITs ; (Pos ; Positions) > , SDRest) , 
			  VarIndex > 
		if < < V ; MatchedITs ; Positions > , SDRest > := in(ITs1, Vars, SD, empty) .
	
	*** base case (given terms have different roots or are variables and
	*** no assignment list already exists):
	*** introduce new variable here
	ceq $antiunify((< Key , T > , ITs), Coas, SD, Vars, VarIndex, Pos) = 
		< Vfresh , (< Vfresh ; (< Key , T > , ITs) ; Pos > , SD) , s VarIndex >
		if < empty , SD > := in((< Key , T > , ITs), Vars, SD, empty) /\
 		   diffRootsOrVars((< Key , T > , ITs)) /\
		   Vfresh := createVariable(VarIndex, getType(T, Coas)) .
		   	
	*** recursive case (give terms have equal non-variable roots):
	*** antiunify subterms and introduce equal root with resulting subterms
	*** here
	ceq $antiunify((< Key , T > , ITs), Coas, SD, Vars, VarIndex, Pos) =
		if SubLGGs == empty		*** T , TL equal constants
		then < T , SD , VarIndex >
		else < root(T) [ SubLGGs ] , UpdSD , UpdIndex >
		fi
		if equalNonVarRoots((< Key , T > , ITs)) /\
		   < SubLGGs , UpdSD , UpdIndex > := 
		   ***auSubterms(createSubtermsList((< Key , T > , ITs)), 
		   auSubterms(createSubtermsList(replMetaVars((< Key , T > , ITs), Coas)), 
			       Coas, SD, Vars, VarIndex, (Pos . 1)) .
			       
	op replMetaVars : IndexedTerms Coarities -> IndexedTerms .
	eq replMetaVars(ITs, Coas) = appRepl(findRepl(ITs, Coas), ITs) .
	
	op findRepl : IndexedTerms Coarities -> Term .
	eq findRepl((< Key , C > , ITs), Coas) = C .
	eq findRepl((< Key , Root [ Subterms ] > , ITs), Coas) = 
		Root [ createMetaVars(Subterms, Coas) ] .

	op appRepl : Term IndexedTerms -> IndexedTerms .
	eq appRepl(Repl, none) = none .
	eq appRepl(Repl, (< Key , T > , ITs)) = 
		if metaVar?(T)
		then < Key , Repl > , appRepl(Repl, ITs)
		else < Key , T > , appRepl(Repl, ITs)
		fi .
		
	op createMetaVars : TermList Coarities -> TermList .
	eq createMetaVars(empty, Coas) = empty .
	eq createMetaVars((T , TL), Coas) = 
		createMetaVariable(0, getType(T, Coas)) , createMetaVars(TL, Coas) .
		
	op createMetaVariable : Nat Type -> Variable .
	eq createMetaVariable(Index, Sor) = 
		qid("?X" + string(Index, 10) + ":" + string(Sor)) .
		

	*** checks whether indexed terms exist as assignments (up to substitution
	*** of '?:MetaVar) for a variable in substitution data; if yes,
	*** the assignment data is returned, if no, empty is returned;
	*** since substitution data is a set, the function is not determined,
	*** assignments for given initial variables are preferred but 
	*** the function is still not deterministic	
	op in : IndexedTerms Variables SubstitutionData SubstitutionData -> InResult .
	eq in(ITs, noVars, empty, SD) = < empty , SD > .
	ceq in(ITs1, noVars, (< V ; ITs2 ; Positions > , SDRest), SD) = 
		if MatchedITs == none
		then in(ITs1, noVars, SDRest, (< V ; ITs2 ; Positions > , SD))
		else < < V ; MatchedITs ; Positions > , (SDRest , SD) >
		fi 
		if MatchedITs := matchAssignments(ITs1, ITs2, none) .
	ceq in(ITs1, (V # Vars), (< V ; ITs2 ; Positions > , SDRest), SD) = 
		if MatchedITs == none
		then in(ITs1, Vars, SDRest, (< V ; ITs2 ; Positions > , SD))
		else < < V ; MatchedITs ; Positions > , (SDRest , SD) >
		fi 
		if MatchedITs := matchAssignments(ITs1, ITs2, none) .
		
	op matchAssignments : IndexedTerms IndexedTerms IndexedTerms 
								-> IndexedTerms .
	eq matchAssignments(none, none, ITs) = ITs .
	ceq matchAssignments((< Key , T1 > , ITs1), (< Key , T2 > , ITs2), ITs) =
		if Unifyer == noUnifyer
		then none
		else matchAssignments(ITs1, ITs2, (< Key , Unifyer > , ITs))
		fi 
		if Unifyer := unifyMeta(T1, T2) .
		
	sort UnifyResult .
	subsort TermList < UnifyResult .
	op noUnifyer : -> UnifyResult [ctor] .
		
	op unifyFinish1 : Term UnifyResult -> UnifyResult .
	eq unifyFinish1(T, noUnifyer) = noUnifyer .
	eq unifyFinish1(T, Unifyer) = (T , Unifyer) [owise] .
	
	op unifyFinish2 : Qid UnifyResult UnifyResult -> UnifyResult .
	eq unifyFinish2(Root, Subunifyer, Unifyer) =
		if (Subunifyer == noUnifyer) or (Unifyer == noUnifyer)
		then noUnifyer
		else (Root [ Subunifyer ] , Unifyer)
		fi .
		
		
	op unifyMeta : TermList TermList -> UnifyResult .
	eq unifyMeta(empty, empty) = empty .
	eq unifyMeta((C , TL1), (C , TL2)) =
		unifyFinish1(C, unifyMeta(TL1, TL2)) .
	eq unifyMeta((V , TL1), (T , TL2)) =
		if (V == T) or metaVar?(V)
		then unifyFinish1(T, unifyMeta(TL1, TL2))
		else noUnifyer
		fi .
	eq unifyMeta((T , TL1), (V , TL2)) =
		if (V == T) or metaVar?(V)
		then unifyFinish1(T, unifyMeta(TL1, TL2))
		else noUnifyer
		fi .
	eq unifyMeta((Root [ Subterms1 ] , TL1), (Root [ Subterms2 ] , TL2)) =
		unifyFinish2(Root, unifyMeta(Subterms1, Subterms2), unifyMeta(TL1, TL2)) .
	eq unifyMeta(TL1, TL2) = noUnifyer [owise] .
		
		
	op metaVar? : Term -> Bool .
	eq metaVar?(V) = substr(string(V), 0, 1) == "?" .
	eq metaVar?(T) = false [owise] .
	
		

	*** PRE: non-empty term list; roots of given terms are all equal
	op createSubtermsList : IndexedTerms -> IndexedTermsList .
	eq createSubtermsList((< Key , C > , ITs)) = empty .
	eq createSubtermsList(< Key , Root [ Subterms ] >) = 
		initSubtermsList(Key, Subterms) .
	eq createSubtermsList((< Key , Root [ Subterms ] > , ITs)) =
		addSubterms(Key, Subterms, createSubtermsList(ITs)) .
		
	op initSubtermsList : Nat TermList -> IndexedTermsList .
	eq initSubtermsList(Key, empty) = empty .
	eq initSubtermsList(Key, (Subterm , RemSubts)) = 
		< Key , Subterm > + initSubtermsList(Key, RemSubts) .
		
	*** PRE: length(TermList) = length(TermListList)
	op addSubterms : Nat TermList IndexedTermsList -> IndexedTermsList .
	eq addSubterms(Key, empty, empty) = empty .
	eq addSubterms(Key, (Subterm , RemSubts), (ISubts + ISubtsList)) = 
		(< Key , Subterm > , ISubts) +
			addSubterms(Key, RemSubts, ISubtsList) .
		   
	
		   
	op auSubterms : 
		IndexedTermsList Coarities SubstitutionData Variables Nat Position 
			-> AUSubResult .
	eq auSubterms(empty, Coas, SD, Vars, VarIndex, Pos) = 
		< empty , SD , VarIndex > .
	ceq auSubterms((ISubts + ISubtsList), Coas, SD, Vars, VarIndex, 
			(Pos . N)) =
		< (SubLGG , SubLGGs) , ResultSD , ResultIndex > 
		if < SubLGG , UpdSD , UpdIndex > := 
			$antiunify(ISubts, Coas, SD, Vars, VarIndex, (Pos . N)) /\
		   < SubLGGs , ResultSD , ResultIndex > := 
		   	auSubterms(ISubtsList, Coas, UpdSD, Vars, UpdIndex,
				    (Pos . (s N))) .
	
	op diffRootsOrVars : IndexedTerms -> Bool .
	eq diffRootsOrVars(ITs) = 
		$diffRootsOrVars(ITs) or onlyVars(ITs) .
	
	op $diffRootsOrVars : IndexedTerms -> Bool .
	eq $diffRootsOrVars(none) = false .
	***eq diffRootsOrVars(< Key , T >) = isVar(T) .
	eq $diffRootsOrVars(< Key , T >) = isVar(T) and not(metaVar?(T)) .
	***eq diffRootsOrVars((< Key1 , T > , < Key2 , S > , ITs)) = 
	***	if isVar(T) or (root(T) =/= root(S))
	***	then true
	***	else diffRootsOrVars((< Key2 , S > , ITs)) 
	***	fi .
	eq $diffRootsOrVars((< Key1 , T > , < Key2 , S > , ITs)) = 
		if (isVar(T) and not(metaVar?(T))) or 
		   ((root(T) =/= root(S)) and not(metaVar?(T) or metaVar?(S)))
		then true
		else $diffRootsOrVars((< Key2 , S > , ITs)) 
		fi .
		
	op onlyVars : IndexedTerms -> Bool .
	eq onlyVars(none) = true .
	eq onlyVars((< Key , T > , ITs)) = 
		if isVar(T)
		then onlyVars(ITs)
		else false
		fi .
		
	op equalNonVarRoots : IndexedTerms -> Bool .
	eq equalNonVarRoots(ITs) = not(diffRootsOrVars(ITs)) .
	
		
	*** op $makeEmptySubstitutions : TermList -> SubstitutionList .
	*** eq $makeEmptySubstitutions(empty) = (empty).SubstitutionList .
	*** eq $makeEmptySubstitutions((T , TL)) = 
	*** 	none , $makeEmptySubstitutions(TL) .
	
endfm
